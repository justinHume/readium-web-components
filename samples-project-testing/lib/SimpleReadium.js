// Taken from https://raw.github.com/readium/readium/master/scripts/epub_reading_system.js

// The epubReadingSystem object provides an interface through which a Scripted Content 
// Document can query information about a User's Reading System.
//
// More information is available [here](http://idpf.org/epub/30/spec/epub30-contentdocs.html#app-epubReadingSystem)

navigator.epubReadingSystem = {
	name: "Readium.js",
	version: "0.0.1",
	layoutStyle: "paginated",

	hasFeature: function(feature, version) {

		// for now all features must be version 1.0 so fail fast if the user has asked for something else
		if(version && version !== "1.0") {
			return false;
		}

		if(feature === "dom-manipulation") {
			// Scripts may make structural changes to the documentâ€™s DOM (applies to spine-level scripting only).
			return true;	
		} 
		if(feature === "layout-changes") {
			// Scripts may modify attributes and CSS styles that affect content layout (applies to spine-level scripting only).
			return true;
		}	
		if(feature === "touch-events") {
			// The device supports touch events and the Reading System passes touch events to the content.
			return false;
		}
		if(feature === "mouse-events") {
			// The device supports mouse events and the Reading System passes mouse events to the content.
			return true;
		}
		if(feature === "keyboard-events") {
			// The device supports keyboard events and the Reading System passes keyboard events to the content.
			return true;
		}	
		if(feature === "spine-scripting") {
			//Spine-level scripting is supported.
			return true;
		}

		return false;

	}
}

var SimpleReadiumJs = function (elementToBindReaderTo, viewerPreferences, packageDocumentURL, packageDocumentXML, renderStrategy) {
    
    // Epub modules
    var EpubCFI = {};
    var EpubReflowable = {};
    var EpubFixed = {};
    var EpubParser = {};
    var Epub = {};
    var EpubReader = {};
    var EpubAnnotations = {};

    // Rationale: The order of these matters
    var EpubCFIModule = function () {

    var EPUBcfi = {};

    EPUBcfi.Parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "fragment": parse_fragment,
        "range": parse_range,
        "path": parse_path,
        "local_path": parse_local_path,
        "indexStep": parse_indexStep,
        "indirectionStep": parse_indirectionStep,
        "terminus": parse_terminus,
        "idAssertion": parse_idAssertion,
        "textLocationAssertion": parse_textLocationAssertion,
        "parameter": parse_parameter,
        "csv": parse_csv,
        "valueNoSpace": parse_valueNoSpace,
        "value": parse_value,
        "escapedSpecialChars": parse_escapedSpecialChars,
        "number": parse_number,
        "integer": parse_integer,
        "space": parse_space,
        "circumflex": parse_circumflex,
        "doubleQuote": parse_doubleQuote,
        "squareBracket": parse_squareBracket,
        "parentheses": parse_parentheses,
        "comma": parse_comma,
        "semicolon": parse_semicolon,
        "equal": parse_equal,
        "character": parse_character
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "fragment";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_fragment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "epubcfi(") {
          result0 = "epubcfi(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"epubcfi(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_range();
          if (result1 === null) {
            result1 = parse_path();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, fragmentVal) { 
                
                return { type:"CFIAST", cfiString:fragmentVal };
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_range() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result2 = ",";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_local_path();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  result4 = ",";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_local_path();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {
        
                return { type:"range", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };
          })(pos0, result0[0], result0[1], result0[3], result0[5]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal) { 
        
                return { type:"path", path:stepVal, localPath:localPathVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_indexStep();
        if (result1 === null) {
          result1 = parse_indirectionStep();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_indexStep();
            if (result1 === null) {
              result1 = parse_indirectionStep();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_terminus();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, localPathStepVal, termStepVal) { 
        
                return { steps:localPathStepVal, termStep:termStepVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indexStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indirectionStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!/") {
          result0 = "!/";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_terminus() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_textLocationAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, textOffsetValue, textLocAssertVal) { 
        
                return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_idAssertion() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_value();
        if (result0 !== null) {
          result0 = (function(offset, idVal) { 
        
                return idVal; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_textLocationAssertion() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_csv();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_parameter();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, csvVal, paramVal) { 
        
                return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parameter() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_valueNoSpace();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 61) {
              result2 = "=";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_valueNoSpace();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, paramLHSVal, paramRHSVal) { 
        
                return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal }; 
            })(pos0, result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_csv() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_value();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_value();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preAssertionVal, postAssertionVal) { 
        
                return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal }; 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_valueNoSpace() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
          if (result1 === null) {
            result1 = parse_space();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
              if (result1 === null) {
                result1 = parse_space();
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_escapedSpecialChars() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_circumflex();
        if (result0 !== null) {
          result1 = parse_circumflex();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_circumflex();
          if (result0 !== null) {
            result1 = parse_squareBracket();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            result0 = parse_circumflex();
            if (result0 !== null) {
              result1 = parse_parentheses();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              result0 = parse_circumflex();
              if (result0 !== null) {
                result1 = parse_comma();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                result0 = parse_circumflex();
                if (result0 !== null) {
                  result1 = parse_semicolon();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_circumflex();
                  if (result0 !== null) {
                    result1 = parse_equal();
                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, escSpecCharVal) { 
                
                return escSpecCharVal[1]; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        if (/^[1-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            pos2 = pos;
            result2 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result2 !== null) {
              if (/^[1-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, intPartVal, fracPartVal) { 
        
                return intPartVal.join('') + "." + fracPartVal.join(''); 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 === null) {
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, integerVal) { 
        
                if (integerVal === "0") { 
                  return "0";
                } 
                else { 
                  return integerVal[0].concat(integerVal[1].join(''));
                }
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_circumflex() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 94) {
          result0 = "^";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"^\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "^"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuote() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return '"'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_squareBracket() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parentheses() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_equal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_character() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 === null) {
          if (/^[A-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Z]");
            }
          }
          if (result0 === null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

    // Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL). 
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

EPUBcfi.CFIInstructions = {

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	// Description: Follows a step
	// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
	//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been 
	//   excluded.
	// REFACTORING CANDIDATE: This should be called "followIndexStep"
	getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		// Find the jquery index for the current node
		var $targetNode;
		if (CFIStepValue % 2 == 0) {

			$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}
		else {

			$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}

		return $targetNode;
	},

	// Description: This instruction executes an indirection step, where a resource is retrieved using a 
	//   link contained on a attribute of the target element. The attribute that contains the link differs
	//   depending on the target. 
	// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to 
	//   the cross origin security policy
	followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var that = this;
		var $contentDocument; 
		var $blacklistExcluded;
		var $startElement;
		var $targetNode;

		// TODO: This check must be expanded to all the different types of indirection step
		// Only expects iframes, at the moment
		if ($currNode === undefined || !$currNode.is("iframe")) {

			throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
		}

		// Check node type; only iframe indirection is handled, at the moment
		if ($currNode.is("iframe")) {

			// Get content
			$contentDocument = $currNode.contents();

			// Go to the first XHTML element, which will be the first child of the top-level document object
			$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
			$startElement = $($blacklistExcluded[0]);

			// Follow an index step
			$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return that shit!
			return $targetNode; 
		}

		// TODO: Other types of indirection
		// TODO: $targetNode.is("embed")) : src
		// TODO: ($targetNode.is("object")) : data
		// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
	},

	// Description: Injects an element at the specified text node
	// Arguments: a cfi text termination string, a jquery object to the current node
	// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus
	textTermination : function ($currNode, textOffset, elementToInject) {

		var $injectedElement;
		// Get the first node, this should be a text node
		if ($currNode === undefined) {

			throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
		} 
		else if ($currNode.length === 0) {

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
		}

		$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
		return $injectedElement;
	},

	// Description: Checks that the id assertion for the node target matches that on 
	//   the found node. 
	targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

		if ($foundNode.attr("id") === idAssertion) {

			return true;
		}
		else {

			return false;
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
	elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var $targetNode;
		var $blacklistExcluded;
		var numElements;
		var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

		$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
		numElements = $blacklistExcluded.length;

		if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

			throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
		}

	    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
		return $targetNode;
	},

	retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

		return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
	},

	indexOutOfRange : function (targetIndex, numChildElements) {

		return (targetIndex > numChildElements - 1) ? true : false;
	},

	// Rationale: In order to inject an element into a specific position, access to the parent object 
	//   is required. This is obtained with the jquery parent() method. An alternative would be to 
	//   pass in the parent with a filtered list containing only children that are part of the target text node.
	injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

		var nodeNum;
		var currNodeLength;
		var currTextPosition = 0;
		var nodeOffset;
		var originalText;
		var $injectedNode;
		var $newTextNode;
		// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
		for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {

			if ($textNodeList[nodeNum].nodeType === 3) {

				currNodeMaxIndex = ($textNodeList[nodeNum].nodeValue.length - 1) + currTextPosition;
				nodeOffset = textOffset - currTextPosition;

				if (currNodeMaxIndex >= textOffset) {

					// This node is going to be split and the components re-inserted
					originalText = $textNodeList[nodeNum].nodeValue;	

					// Before part
				 	$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

					// Injected element
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

					// After part
					$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
					$($newTextNode).insertAfter($injectedNode);

					return $injectedNode;
				}
				else {

					currTextPosition = currTextPosition + currNodeMaxIndex;
				}
			}
		}

		throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
	},

	// Description: This method finds a target text node and then injects an element into the appropriate node
	// Arguments: A step value that is an odd integer. A current node with a set of child elements.
	// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to 
	//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
	//   the set of nodes that compromised the original target text node are inferred and returned.
	// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, 
	//   element nodes (maybe), or possibly a mix. 
	// REFACTORING CANDIDATE: This method is pretty long. Worth investigating to see if it can be refactored into something clearer.
	inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {
		
		var $elementsWithoutMarkers;
		var currTextNodePosition;
		var logicalTargetPosition;
		var nodeNum;
		var $targetTextNodeList;

		// Remove any cfi marker elements from the set of elements. 
		// Rationale: A filtering function is used, as simply using a class selector with jquery appears to 
		//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
		$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

		// Convert CFIStepValue to logical index; assumes odd integer for the step value
		logicalTargetPosition = (parseInt(CFIStepValue) + 1) / 2;

		// Set text node position counter
		currTextNodePosition = 1;
		$targetTextNodeList = $elementsWithoutMarkers.filter(
			function () {

				if (currTextNodePosition === logicalTargetPosition) {

					// If it's a text node
					if (this.nodeType === 3) {
						return true; 
					}
					// Any other type of node, move onto the next text node
					else {
						currTextNodePosition++; 
						return false;
					}
				}
				// In this case, don't return any elements
				else {

					// If its the last child and it's not a text node, there are no text nodes after it
					// and the currTextNodePosition shouldn't be incremented
					if (this.nodeType !== 3 && this !== $elementsWithoutMarkers.lastChild) {
						currTextNodePosition++;
					}

					return false;
				}
			}
		);

		// The filtering above should have counted the number of "logical" text nodes; this can be used to 
		// detect out of range errors
		if ($targetTextNodeList.length === 0) {

			throw EPUBcfi.OutOfRangeError(logicalTargetPosition, currTextNodePosition - 1, "Index out of range");
		}

		// return the text node list
		return $targetTextNodeList;
	},

	applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

        var $filteredElements;

        $filteredElements = $elements.filter(
            function () {

                var $currElement = $(this);
                var includeInList = true;

                if (classBlacklist) {

                	// Filter each element with the class type
                	$.each(classBlacklist, function (index, value) {

	                    if ($currElement.hasClass(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
                	});
                }

                if (elementBlacklist) {
                	
	                // For each type of element
	                $.each(elementBlacklist, function (index, value) {

	                    if ($currElement.is(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

				if (idBlacklist) {
                	
	                // For each type of element
	                $.each(idBlacklist, function (index, value) {

	                    if ($currElement.attr("id") === value) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

                return includeInList;
            }
        );

        return $filteredElements;
    }
};



    // Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

EPUBcfi.Interpreter = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Find the content document referenced by the spine item. This should be the spine item 
    //   referenced by the first indirection step in the CFI.
    // Rationale: This method is a part of the API so that the reading system can "interact" the content document 
    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with 
    //   the reading system, as it stands now. 
    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var $packageDocument = $(packageDocument);
        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        if (!CFIAST || CFIAST.type !== "CFIAST") { 
            throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
        }

        // Interpet the path node (the package document step)
        var $packageElement = $($("package", $packageDocument)[0]);
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);
        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);

        if (foundHref) {
            return foundHref;
        }
        else {
            return undefined;
        }
    },

    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

        // Return the element that was injected into
        return $currElement;
    },

    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(rangeCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        var $range1TargetElement;
        var $range2TargetElement;

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps in the first local path
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the first range local_path
        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);

        // Interpret the second range local_path
        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);

        // Return the element that was injected into
        return {
            startElement : $range1TargetElement[0],
            endElement : $range2TargetElement[0]
        };
    },

    // Description: This method will return the element or node (say, a text node) that is the final target of the 
    //   the CFI.
    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;
    },

    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(rangeCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        var $range1TargetElement;
        var $range2TargetElement;
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret first range local_path
        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Interpret second range local_path
        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return {
            startElement : $range1TargetElement[0],
            endElement : $range2TargetElement[0]
        };
    },

    // Description: This method allows a "partial" CFI to be used to reference a target in a content document, without a 
    //   package document CFI component. 
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;        
    },

    // Description: This method allows a "partial" CFI to be used, with a content document, to return the text node and offset 
    //    referenced by the partial CFI.
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var textOffset;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);
        return { textNode : $currElement,
                 textOffset : textOffset
            };
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    getFirstIndirectionStepNum : function (CFIAST) {

        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it 
        //   references is already loaded and has been passed to this method
        var stepNum = 0;
        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indirectionStep") {
                return stepNum;
            }
        }
    },

    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the 
    //   starting step... probably a good idea, this would make the meaning of this method clearer.
    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        var stepNum = startStepNum;
        var nextStepNode;
        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {
        
            nextStepNode = localPathNode.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
        }

        return $currElement;
    },

    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

            throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
        }

        // Index step
        var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Check the id assertion, if it exists
        if (indexStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

            throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
        }

        // Indirection step
        var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
            indirectionStepNode.stepLength, 
            $currElement, 
            classBlacklist, 
            elementBlacklist);

        // Check the id assertion, if it exists
        if (indirectionStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus
    //   to inject content into the found node. This will not always be the case, and different types of interpretation
    //   are probably desired. 
    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

        if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

            throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
        }

        var $injectedElement = EPUBcfi.CFIInstructions.textTermination(
            $currElement, 
            terminusNode.offsetValue, 
            elementToInject
            );

        return $injectedElement;
    },

    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {

        // Interpret the first local_path node, which is a set of steps and and a terminus condition
        var stepNum = 0;
        var nextStepNode;
        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {
        
            nextStepNode = localPathNode.steps[stepNum];
            if (nextStepNode.type === "indexStep") {
                
                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }

            // Found the content document href referenced by the spine item 
            if ($currElement.is("itemref")) {

                return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
            }
        }

        return undefined;
    }
};
    // Description: This is a set of runtime errors that the CFI interpreter can throw. 
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
EPUBcfi.NodeTypeError = function (node, message) {

    function NodeTypeError () {

        this.node = node;
    }

    NodeTypeError.prototype = new Error(message);
    NodeTypeError.constructor = NodeTypeError;

    return new NodeTypeError();
};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

    function OutOfRangeError () {

        this.targetIndex = targetIndex;
        this.maxIndex = maxIndex;
    }

    OutOfRangeError.prototype = new Error(message);
    OutOfRangeError.constructor = OutOfRangeError()

    return new OutOfRangeError();
};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

    function TerminusError () {

        this.terminusType = terminusType;
        this.terminusCondition = terminusCondition;
    }

    TerminusError.prototype = new Error(message);
    TerminusError.constructor = TerminusError();

    return new TerminusError();
};

EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

    function CFIAssertionError () {

        this.expectedAssertion = expectedAssertion;
        this.targetElementAssertion = targetElementAssertion;
    }

    CFIAssertionError.prototype = new Error(message);
    CFIAssertionError.constructor = CFIAssertionError();

    return new CFIAssertionError();
};

    EPUBcfi.Generator = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var docRange;
        var commonAncestor;
        var range1OffsetStep;
        var range1CFI;
        var range2OffsetStep;
        var range2CFI;
        var commonCFIComponent;

        this.validateStartTextNode(rangeStartElement);
        this.validateStartTextNode(rangeEndElement);

        if (rangeStartElement === rangeEndElement) {
            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          
            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), "html", classBlacklist, elementBlacklist, idBlacklist);
            return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1OffsetStep + "," + range2OffsetStep;
        }
        else {

            // Create a document range to find the common ancestor
            docRange = document.createRange();
            docRange.setStart(rangeStartElement, startOffset);
            docRange.setEnd(rangeEndElement, endOffset);
            commonAncestor = docRange.commonAncestorContainer;

            // Generate terminating offset and range 1
            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
            range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;

            // Generate terminating offset and range 2
            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);
            range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;

            // Generate shared component
            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

            // Return the result
            return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
        }
    },

    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {

        var docRange;
        var commonAncestor;
        var range1CFI;
        var range2CFI;
        var commonCFIComponent;

        this.validateStartElement(rangeStartElement);
        this.validateStartElement(rangeEndElement);

        if (rangeStartElement === rangeEndElement) {
            throw new Error("Start and end element cannot be the same for a CFI range");
        }

        // Create a document range to find the common ancestor
        docRange = document.createRange();
        docRange.setStart(rangeStartElement);
        docRange.setEnd(rangeEndElement);
        commonAncestor = docRange.commonAncestorContainer;

        // Generate range 1
        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

        // Generate range 2
        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

        // Generate shared component
        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Return the result
        return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
    },

    // Description: Generates a character offset CFI 
    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the 
    //   content document that contains the text node, the package document for this EPUB.
    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var textNodeStep;
        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartTextNode(startTextNode, characterOffset);

        // Create the text node step
        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), "html", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {

        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartElement(startElement);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startElement), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Remove the ! 
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        this.validateContentDocumentName(contentDocumentName);
        this.validatePackageDocument(packageDocument, contentDocumentName);

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Append an !; this assumes that a CFI content document CFI component will be appended at some point
        return packageDocCFIComponent + "!";
    },

    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $($("spine", packageDocument).children()[spineIndex]);

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Append an !; this assumes that a CFI content document CFI component will be appended at some point
        return packageDocCFIComponent + "!";
    },

    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {

        return "epubcfi(" + packageDocumentCFIComponent + contentDocumentCFIComponent + ")";  
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    validateStartTextNode : function (startTextNode, characterOffset) {
        
        // Check that the text node to start from IS a text node
        if (!startTextNode) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        } else if (startTextNode.nodeType != 3) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        }

        // Check that the character offset is within a valid range for the text node supplied
        if (characterOffset < 0) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
        }
        else if (characterOffset > startTextNode.nodeValue.length) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
        }
    },

    validateStartElement : function (startElement) {

        if (!startElement) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is undefined");
        }

        if (!(startElement.nodeType && startElement.nodeType === 1)) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is not an HTML element");
        }
    },

    validateContentDocumentName : function (contentDocumentName) {

        // Check that the idref for the content document has been provided
        if (!contentDocumentName) {
            throw new Error("The idref for the content document, as found in the spine, must be supplied");
        }
    },

    validatePackageDocument : function (packageDocument, contentDocumentName) {
        
        // Check that the package document is non-empty and contains an itemref element for the supplied idref
        if (!packageDocument) {
            throw new Error("A package document must be supplied to generate a CFI");
        }
        else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
            throw new Error("The idref of the content document could not be found in the spine");
        }
    },

    // Description: Creates a CFI terminating step, to a text node, with a character offset
    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var CFIIndex;
        var indexOfTextNode;
        var preAssertion;
        var preAssertionStartIndex;
        var textLength;
        var postAssertion;
        var postAssertionEndIndex;

        // Find text node position in the set of child elements, ignoring any blacklisted elements 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node index in the parent list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var indexOfFirstInSequence;
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this 
                        //   node is a standard one sandwiched between two element nodes. 
                        if (prevNodeWasTextNode) {
                            indexOfTextNode = indexOfFirstInSequence;
                        }
                        else {
                            indexOfTextNode = index;
                        }
                        
                        // Break out of .each loop
                        return false; 
                    }

                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
                    prevNodeWasTextNode = true;
                    if (!indexOfFirstInSequence) {
                        indexOfFirstInSequence = index;
                    }
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                    indexOfFirstInSequence = undefined;
                }
            }
        );

        // Convert the text node index to a CFI odd-integer representation
        CFIIndex = (indexOfTextNode * 2) + 1;

        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
        //   been temporarily removed. 

        // Add pre- and post- text assertions
        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

        // textLength = $startTextNode[0].nodeValue.length;
        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

        // Gotta infer the correct character offset, as well

        // Return the constructed CFI text node step
        return "/" + CFIIndex + ":" + characterOffset;
         // + "[" + preAssertion + "," + postAssertion + "]";
    },

    // Description: A set of adjacent text nodes can be inferred to have been a single text node in the original document. As such, 
    //   if the character offset is specified for one of the adjacent text nodes, the true offset for the original node must be
    //   inferred.
    findOriginalTextNodeCharOffset : function ($startTextNode, specifiedCharacterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var textLength;
        
        // Find text node position in the set of child elements, ignoring any cfi markers 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node number in the list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var originalCharOffset = -1; // So the character offset is a 0-based index; we'll be adding lengths of text nodes to this number
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        if (prevNodeWasTextNode) {
                            originalCharOffset = originalCharOffset + specifiedCharacterOffset;
                        }
                        else {
                            originalCharOffset = specifiedCharacterOffset;
                        }

                        return false; // Break out of .each loop
                    }
                    else {

                        originalCharOffset = originalCharOffset + this.length;
                    }

                    // save this index as the first in sequence of adjacent text nodes, if not set
                    prevNodeWasTextNode = true;
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                }
            }
        );

        return originalCharOffset;
    },

    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

        var $blacklistExcluded;
        var $parentNode;
        var currNodePosition;
        var CFIPosition;
        var idAssertion;
        var elementStep; 

        // Find position of current node in parent list
        $blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
        $.each($blacklistExcluded, 
            function (index, value) {

                if (this === $currNode[0]) {

                    currNodePosition = index;

                    // Break loop
                    return false;
                }
        });

        // Convert position to the CFI even-integer representation
        CFIPosition = (currNodePosition + 1) * 2;

        // Create CFI step with id assertion, if the element has an id
        if ($currNode.attr("id")) {
            elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
        }
        else {
            elementStep = "/" + CFIPosition;
        }

        // If a parent is an html element return the (last) step for this content document, otherwise, continue.
        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the
        //   top level element.
        $parentNode = $currNode.parent();
        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {
            
            // If the top level node is a type from which an indirection step, add an indirection step character (!)
            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do
            //   not return an indirection character. Every other type of top-level element may require an indirection
            //   step to navigate to, thus requiring that ! is always prepended. 
            if (topLevelElement === 'html') {
                return "!" + elementStep;
            }
            else {
                return elementStep;
            }
        }
        else {
            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
        }
    }
};

    var interpreter = EPUBcfi.Interpreter;
    var generator = EPUBcfi.Generator;
    var instructions = EPUBcfi.CFIInstructions;

    // The public interface
    return {

        getContentDocHref : function (CFI, packageDocument) {
            return interpreter.getContentDocHref(CFI, packageDocument);
        },
        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);
        },
        getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);
        },
        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {
            return generator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);
        },
        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {
            return instructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);
        },
        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);
        },
        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);
        }
    };
};

    var EpubReflowableModule = function(spineObject, viewerSettingsObject, CFIAnnotations, bindings) {

    var EpubReflowable = {};

    // Rationale: The order of these matters
    // Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

EpubReflowable.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});
    
EpubReflowable.ReflowableElementInfo = Backbone.Model.extend({

    initialize : function () {},

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    getElemPageNumber: function(elem, offsetDir, pageWidth, gapWidth, epubContentDocument) {
        
        var $elem;
        var elemWasInvisible = false;
        var rects, shift;
        var elemRectWidth;

        // Rationale: Elements with an epub:type="pagebreak" attribute value are likely to be set as 
        //   display:none, as they indicate the end of a page in the corresponding physical version of a book. We need 
        //   the position of these elements to get the reflowable page number to set in the viewer. Therefore, 
        //   we check if the element has this epub:type value, set it visible, find its location and then set it to 
        //   display:none again. 
        // REFACTORING CANDIDATE: We might want to do this for any element with display:none. 
        $elem = $(elem);
        if ($elem.attr("epub:type") === "pagebreak" && !$elem.is(":visible")) {

            elemWasInvisible = true;
            $elem.show();
        }

        rects = elem.getClientRects();
        if(!rects || rects.length < 1) {
            // if there were no rects the elem had display none
            return -1;
        }

        shift = rects[0][offsetDir];

        // calculate to the center of the elem
        // Rationale: The -1 or +1 adjustment is to account for the case in which the target element for which the shift offset
        //   is calculated is at the edge of a page and has 0 width. In this case, if a minor arbitrary adjustment is not applied, 
        //   the calculated page number will be off by 1.   
        elemRectWidth = rects[0].left - rects[0].right;
        if (offsetDir === "right" && elemRectWidth === 0) {
            shift -= 1;
        }
        else if (offsetDir === "left" && elemRectWidth === 0) {
            shift += 1;
        } // Rationale: There shouldn't be any other case here. The explict second (if else) condition is for clarity.
        shift += Math.abs(elemRectWidth);
        
        // Re-hide the element if it was original set as display:none
        if (elemWasInvisible) {
            $elem.hide();
        }

        // `clientRects` are relative to the top left corner of the frame, but
        // for right to left we actually need to measure relative to right edge
        // of the frame
        if (offsetDir === "right") {
            // the right edge is exactly `this.page_width` pixels from the right 
            // edge
            shift = pageWidth - shift;
        }
        // less the amount we already shifted to get to cp
        shift -= parseInt(epubContentDocument.style[offsetDir], 10); 
        return Math.ceil( shift / (pageWidth + gapWidth) );
    },

    getElemPageNumberById: function(elemId, epubContentDocument, offsetDir, pageWidth, gapWidth) {

        var elem = $(epubContentDocument).find("#" + elemId);
        if (elem.length == 0) {
            return -1;
        }
        else {
            return this.getElemPageNumber(elem[0], offsetDir, pageWidth, gapWidth, epubContentDocument);
        }
    },

    // Currently for left-to-right pagination only
    findVisibleCharacterOffset : function($textNode, epubContentDocument) {

        var $parentNode;
        var elementTop;
        var elementBottom;
        var POSITION_ERROR_MARGIN = 5;
        var $document;
        var documentTop;
        var documentBottom;
        var percentOfTextOffPage;
        var characterOffset;

        // Get parent; text nodes do not have visibility properties.
        $parentNode = $textNode.parent();

        // Get document
        $document = $(epubContentDocument);

        // Find percentage of visible node on page
        documentTop = $document.position().top;
        documentBottom = documentTop + $document.height();

        elementTop = $parentNode.offset().top;
        elementBottom = elementTop + $parentNode.height();

        // Element overlaps top of the page
        if (elementTop < documentTop) {

            percentOfTextOffPage = Math.abs(elementTop - documentTop) / $parentNode.height();
            characterOffsetByPercent = Math.ceil(percentOfTextOffPage * $textNode[0].length);
            characterOffset = Math.ceil(0.5 * ($textNode[0].length - characterOffsetByPercent)) + characterOffsetByPercent;
        }
        // Element is full on the page
        else if (elementTop >= documentTop && elementTop <= documentBottom) {
            characterOffset = 1;
        }
        // Element overlaps bottom of the page
        else if (elementTop < documentBottom) {
            characterOffset = 1;
        }

        return characterOffset;
    },

    // TODO: Extend this to be correct for right-to-left pagination
    findVisibleTextNode: function (epubContentDocument, isTwoUp, columnGap, columnWidth) {

        var documentLeft = 0;
        var documentRight;
        var doc;
        var $elements;
        var $firstVisibleTextNode;

        // Rationale: The intention here is to get a list of all the text nodes in the document, after which we'll
        //   reduce this to the subset of text nodes that is visible on the page. We'll then select one text node
        //   for which we can create a character offset CFI. This CFI will then refer to a "last position" in the 
        //   EPUB, which can be used if the reader re-opens the EPUB.
        // REFACTORING CANDIDATE: The "audiError" check is a total hack to solve a problem for a particular epub. This 
        //   issue needs to be addressed.
        $elements = $("body", epubContentDocument).find(":not(iframe)").contents().filter(function () {
            if (this.nodeType === 3 && !$(this).parent().hasClass("audiError")) {
                return true;
            } else {
                return false;
            }
        });

        doc = epubContentDocument;

        if (isTwoUp) {
            documentRight = documentLeft + columnGap + (columnWidth * 2);
        } 
        else {
            documentRight = documentLeft + $(doc).width();
        }

        // Find the first visible text node 
        $.each($elements, function() {

            var POSITION_ERROR_MARGIN = 5;
            var $textNodeParent = $(this).parent();
            var elementLeft = $textNodeParent.position().left;
            var elementRight = elementLeft + $textNodeParent.width();
            var nodeText;

            // Correct for minor right and left position errors
            elementLeft = Math.abs(elementLeft) < POSITION_ERROR_MARGIN ? 0 : elementLeft;
            elementRight = Math.abs(elementRight - documentRight) < POSITION_ERROR_MARGIN ? documentRight : elementRight;

            // Heuristics to find a text node with actual text
            nodeText = this.nodeValue.replace(/\n/g, "");
            nodeText = nodeText.replace(/ /g, "");

            if (elementLeft <= documentRight 
                && elementRight >= documentLeft
                && nodeText.length > 10) { // 10 is so the text node is actually a text node with writing - probably

                $firstVisibleTextNode = $(this);

                // Break the loop
                return false;
            }
        });

        return $firstVisibleTextNode;
    },

    // The package document needs to get passed into the view, or the API needs to change. This is not critical at the moment.
    //
    // // Description: Generates a CFI for an element is that is currently visible on the page. This CFI and a last-page payload
    // //   is then saved for the current EPUB.
    // savePosition : function () {

    //     var $visibleTextNode;
    //     var CFI;

    //     // Get first visible element with a text node 
    //     $visibleTextNode = this.reflowableElementsInfo.findVisibleTextNode(
    //         this.getEpubContentDocument(), 
    //         this.viewerModel.get("two_up"),
    //         // REFACTORING CANDIDATE: These two properties should be stored another way. This should be 
    //         //   temporary.
    //         this.reflowablePaginator.gap_width,
    //         this.reflowablePaginator.page_width
    //         );

    //     CFI = this.annotations.findExistingLastPageMarker($visibleTextNode);
    //     if (!CFI) {

    //      CFI = this.annotations.generateCharacterOffsetCFI(
    //          this.reflowableElementsInfo.findVisibleCharacterOffset($visibleTextNode, this.getEpubContentDocument()),
                // $visibleTextNode[0],
                // this.spineItemModel.get("idref"),
                // this.epubController.getPackageDocumentDOM()
       //       );
    //     }
    //     this.annotations.saveAnnotation(CFI, this.spineItemModel.get("spine_index"));
    // },

    findVisiblePageElements: function(flowingWrapper, epubContentDocument) {

        var $elements = $(epubContentDocument).find("[id]");
        var doc = epubContentDocument;
        var doc_top = 0;
        var doc_left = 0;
        var doc_right = doc_left + $(doc).width();
        var doc_bottom = doc_top + $(doc).height();
        
        var visibleElms = this.filterElementsByPosition(flowingWrapper, $elements, doc_top, doc_bottom, doc_left, doc_right);
            
        return visibleElms;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    // returns all the elements in the set that are inside the box
    filterElementsByPosition: function(flowingWrapper, $elements, documentTop, documentBottom, documentLeft, documentRight) {
        
        var $visibleElms = $elements.filter(function(idx) {
            var elm_top = $(flowingWrapper).offset().top;
            var elm_left = $(flowingWrapper).offset().left;
            var elm_right = elm_left + $(flowingWrapper).width();
            var elm_bottom = elm_top + $(flowingWrapper).height();
            
            var is_ok_x = elm_left >= documentLeft && elm_right <= documentRight;
            var is_ok_y = elm_top >= documentTop && elm_bottom <= documentBottom;
            
            return is_ok_x && is_ok_y;
        });  

        return $visibleElms;
    }
});
    EpubReflowable.ReflowableLayout = Backbone.Model.extend({

    initialize: function (options) {

		this.epubCFI = new EpubCFIModule();
    },

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initializeContentDocument : function (epubContentDocument, readiumFlowingContent, linkClickHandler, handlerContext, keydownHandler, bindings) {

        var triggers;

        this.applySwitches(epubContentDocument); 
        this.injectMathJax(epubContentDocument);
        this.injectLinkHandler(epubContentDocument, linkClickHandler, handlerContext);
        triggers = this.parseTriggers(epubContentDocument);
        this.applyTriggers(epubContentDocument, triggers);
        $(epubContentDocument).attr('title');

        this.injectKeydownHandler(
            readiumFlowingContent, 
            keydownHandler, 
            handlerContext
        );
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE HELPERS                                                                     //
    // ------------------------------------------------------------------------------------ //

    applyTriggers: function (epubContentDocument, triggers) {

        for(var i = 0 ; i < triggers.length; i++) {
            triggers[i].subscribe(epubContentDocument.parentNode);
        }
    },

    // Description: For reflowable content we only add what is in the body tag.
    //   Lots of times the triggers are in the head of the dom
    parseTriggers: function (epubContentDocument) {

        var triggers = [];
        $('trigger', epubContentDocument.parentNode).each(function(index, triggerElement) {
            triggers.push(new EpubReflowable.Trigger(triggerElement) );
        });
        
        return triggers;
    },

    // Description: Parse the epub "switch" tags and hide
    //   cases that are not supported
    applySwitches: function (epubContentDocument) {

        // helper method, returns true if a given case node
        // is supported, false otherwise
        var isSupported = function(caseNode) {

            var ns = $(caseNode).attr("required-namespace");
            if(!ns) {
                // the namespace was not specified, that should
                // never happen, we don't support it then
                console.log("Encountered a case statement with no required-namespace");
                return false;
            }
            // all the xmlns's that readium is known to support
            // TODO this is going to require maintanence
            var supportedNamespaces = ["http://www.w3.org/1998/Math/MathML"];
            return _.include(supportedNamespaces, ns);
        };

        $('switch', epubContentDocument.parentNode).each(function(index, switchElement) {
            
            // keep track of whether or not we found one
            var found = false;

            $('case', switchElement).each(function(index, caseElement) {

                if (!found && isSupported(caseElement)) {
                    found = true; // we found the node, don't remove it
                }
                else {
                    $(caseElement).remove(); // remove the node from the dom
                }
            });

            if (found) {
                // if we found a supported case, remove the default
                $('default', switchElement).remove();
            }
        })
    },

    // Description: Inject mathML parsing code into the content document iframe
    injectMathJax : function (epubContentDocument) {

        var script;
        var head;
        head = $("head", epubContentDocument)[0];
        
        // Rationale: If the content doc is SVG there is no head, and thus
        // mathjax will not be required
        if (head) {
            script = document.createElement("script");
            script.type = "text/javascript";
            script.src = "https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
            head.appendChild(script);
        }
    },

    injectLinkHandler: function (epubContentDocument, linkClickHandler, handlerContext) {

        $('a', epubContentDocument).click(function (e) {
            linkClickHandler.call(handlerContext, e);
        });
    },

    injectKeydownHandler : function (epubContentDocument, keydownHandler, handlerContext) {

        $(epubContentDocument).on("keydown", function (e) {
            keydownHandler.call(handlerContext, e);
        });
    }
});
    // Description: This model is responsible determining page numbers to display for reflowable EPUBs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer.

EpubReflowable.ReflowablePageNumberLogic = Backbone.Model.extend({

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initialize: function () {},

    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //  )
    getPageNumbers : function (gotoPageNumber, twoUp, firstPageOffset) {

        if (twoUp) {
            
            if (firstPageOffset) {

                // EVEN_PAGE |spine| ODD_PAGE
                if (gotoPageNumber % 2 === 1) {
                    return [gotoPageNumber - 1, gotoPageNumber];
                }
                else {
                    return [gotoPageNumber, gotoPageNumber + 1];
                }
            }
            else {
                // ODD_PAGE |spine| EVEN_PAGE
                if (gotoPageNumber % 2 === 1) {
                    return [gotoPageNumber, gotoPageNumber + 1];    
                } 
                else {
                    return [gotoPageNumber - 1, gotoPageNumber];
                }
            }   
        }
        else {  
            return [gotoPageNumber];
        }
    },

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
    //  )
    getPreviousPageNumbers: function (currentPages, twoUp) {

        var previousVisiblePageNumber = currentPages[0] - 1;

        if (!twoUp){

            return [previousVisiblePageNumber];
        }
        else {

            return [previousVisiblePageNumber - 1, previousVisiblePageNumber];
        }
    },

    // Description: Get the pages to display when moving in reading order
    // Arguments (
    //  )
    getNextPageNumbers : function (currentPages, twoUp) {

        // Rationale: The length will be 1 or 2.
        var highestVisiblePageNumber = currentPages[currentPages.length - 1];
        var firstVisiblePageNumber = highestVisiblePageNumber + 1;

        if (!twoUp) {

            return [firstVisiblePageNumber];
        }
        else {

            return [firstVisiblePageNumber, firstVisiblePageNumber + 1];
        }
    },

    // Description: This method determines which page numbers to display when switching
    //   between a single page and side-by-side page views and vice versa.
    // Arguments (
    //   displayedPageNumbers (array of integers): An array of page numbers that are currently displayed    
    //   firstPageOffset: Is the first page of a reflowable EPUB offset, to create a blank page for the first page? 
    //  )
    getToggledLayoutPageNumbers : function (displayedPageNumbers, firstPageOffset) {

        var displayed = displayedPageNumbers;
        var twoPagesDisplayed = displayed.length === 2 ? true : false;
        var newPages = [];

        // Two pages are currently displayed; find the single page number to display
        if (twoPagesDisplayed) {

            // Rationale: I think this check is a bit of a hack, for the case in which a set of pages is [0, 1]. Pages are
            //   1-indexed, so the "0" in the 0 index position of the array is not valid.
            if (displayed[0] === 0) {
                newPages[0] = 1;
            } 
            else {
                newPages[0] = displayed[0];
            }
        }
        // A single reflowable page is currently displayed; find two pages to display
        else if (firstPageOffset) {

            if (displayed[0] % 2 === 1) {

                newPages[0] = displayed[0] - 1;
                newPages[1] = displayed[0];
            }
            else {

                newPages[0] = displayed[0];
                newPages[1] = displayed[0] + 1;
            }               
        }
        else {

            if (displayed[0] % 2 === 1) {
                
                newPages[0] = displayed[0];
                newPages[1] = displayed[0] + 1;
            }
            else {
                
                newPages[0] = displayed[0] - 1;
                newPages[1] = displayed[0];
            }
        }

        return newPages;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //
});
    EpubReflowable.ReflowablePagination = Backbone.Model.extend({ 

    defaults : {
        "numberOfPages" : 0,
        "currentPages" : [1]
    },

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initialize : function () {

        // Instantiate an object responsible for deciding which pages to display
        this.pageNumberDisplayLogic = new EpubReflowable.ReflowablePageNumberLogic();
        
        // Rationale: Need to adjust the page number to the last page if, when the number of pages changes, the current
        //   page is greater than the number of changes. 
        // Probably a memory leak here, should add a destructor
        this.on("change:numberOfPages", this.adjustCurrentPage, this);
    },

    onFirstPage : function () {

        // Rationale: Need to check for both single and synthetic page spread
        var oneOfCurrentPagesIsFirstPage = this.get("currentPages")[0] === 1 ? true :
                                           this.get("currentPages")[1] === 1 ? true : false;

        if (oneOfCurrentPagesIsFirstPage) {
            return true;
        }
        else {
            return false;
        }
    },

    onLastPage : function () {

        // Rationale: Need to check for both single and synthetic page spread
        var oneOfCurrentPagesIsLastPage = this.get("currentPages")[0] === this.get("numberOfPages") ? true :
                                          this.get("currentPages")[1] === this.get("numberOfPages") ? true : false;

        if (oneOfCurrentPagesIsLastPage) {
            return true;
        }
        else {
            return false;
        }
    },

    toggleTwoUp : function (twoUp, firstPageIsOffset) { 

        // if (this.epubController.epub.get("can_two_up")) {

        var layoutPageNumbers = this.pageNumberDisplayLogic.getToggledLayoutPageNumbers(
            this.get("currentPages"),
            firstPageIsOffset
        );
        if (!twoUp) {
            layoutPageNumbers = this.adjustForMaxPageNumber(layoutPageNumbers);
        }
        this.set("currentPages", layoutPageNumbers);
        // }   
    },

    prevPage : function (twoUp) {

        var previousPageNumbers = this.pageNumberDisplayLogic.getPreviousPageNumbers(
                                    this.get("currentPages"),
                                    twoUp
                                  );
        this.set("currentPages", previousPageNumbers);
    },

    nextPage : function (twoUp) {

        var nextPageNumbers = this.pageNumberDisplayLogic.getNextPageNumbers(
                                this.get("currentPages"),
                                twoUp
                              );
        this.set("currentPages", nextPageNumbers);
    },

    goToPage : function (pageNumber, twoUp, firstPageIsOffset) {

        var gotoPageNumbers = this.pageNumberDisplayLogic.getPageNumbers(
                            pageNumber,
                            twoUp,
                            firstPageIsOffset
                            );
        this.set("currentPages", gotoPageNumbers);
    },

    resetCurrentPages : function () {

        var originalPageNumbers = this.get("currentPages");
        var adjustedPageNumbers = this.adjustForMaxPageNumber(originalPageNumbers);

        if (adjustedPageNumbers !== originalPageNumbers) {
            this.set("currentPages", adjustedPageNumbers);
        }
    },

    // ------------------------------------------------------------------------------------ //  
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //
    
    adjustForMaxPageNumber : function (newPageNumbers) {

        var currentPages = this.get("currentPages");
        var numberOfPages = this.get("numberOfPages");

        if (newPageNumbers[0] > numberOfPages) {
            return [numberOfPages];
        }
        else {
            return newPageNumbers;
        }
    }
});
    
EpubReflowable.ReflowablePaginator = Backbone.Model.extend({

    initialize: function (options) {},

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    paginateContentDocument : function (isTwoUp, offsetDir, epubContentDocument, readiumFlowingContent, flowingWrapper, firstPageOffset, currentPages, ppd, currentMargin, fontSize) {

        var page = this.adjustIframeColumns(
            offsetDir, 
            epubContentDocument, 
            readiumFlowingContent, 
            flowingWrapper, 
            isTwoUp, 
            firstPageOffset, 
            currentPages, 
            ppd, 
            currentMargin
            );

        var numPages = this.setFontSize(
            fontSize, 
            epubContentDocument, 
            isTwoUp
            );

        return [numPages, page];
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE HELPERS                                                                     //
    // ------------------------------------------------------------------------------------ //

    getColumnAxisCssName : function () {
        var columnAxisName = Modernizr.prefixed('columnAxis') || 'columnAxis';
        return this.createCssPropertyName(columnAxisName);
    },

    getColumnGapCssName : function () {
        var columnGapName = Modernizr.prefixed('columnGap') || 'columnGap';
        return this.createCssPropertyName(columnGapName);
    },

    getColumnWidthCssName : function () {
        var columnWidthName = Modernizr.prefixed('columnWidth') || 'columnWidth';
        return this.createCssPropertyName(columnWidthName);
    },

    createCssPropertyName : function (modernizrName) {

        return modernizrName.replace(/([A-Z])/g, function (modernizrName, m1) {  
            return '-' + m1.toLowerCase(); 
        }).replace(/^ms-/,'-ms-');
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE METHODS
    // ------------------------------------------------------------------------------------ //

    // Description: calculate the number of pages in the current section,
    //   based on section length : page size ratio
    calcNumPages : function (epubContentDocument, isTwoUp, offsetDir) {

        var body, offset, width, num;
        
        // get a reference to the dom body
        body = epubContentDocument;

        // cache the current offset 
        offset = body.style[offsetDir];

        // set the offset to 0 so that all overflow is part of
        // the scroll width
        body.style[offsetDir] = "0px";

        // grab the scrollwidth => total content width
        width = epubContentDocument.scrollWidth;
        this.set("lastScrollWidth", width);

        // reset the offset to its original value
        body.style[offsetDir] = offset;

        // perform calculation and return result...
        num = Math.floor( (width + this.gap_width) / (this.gap_width + this.page_width) );

        // in two up mode, always set to an even number of pages
        if( num % 2 === 0 && isTwoUp) {
            //num += 1;
        }
        return num;
    },

    getFrameWidth : function (flowingWrapperWidth, currentMargin, isTwoUp) {

        var width;
        var margin = currentMargin;
        if (margin === 1) {
            isTwoUp ? (width = 0.95) : (width = 0.90);
        }
        else if (margin === 2) {
            isTwoUp ? (width = 0.89) : (width = 0.80);
        }
        else if (margin === 3) {
            isTwoUp ? (width = 0.83) : (width = 0.70); 
        }
        else if (margin === 4) {
            isTwoUp ? (width = 0.77) : (width = 0.60); 
        }
        else if (margin === 5) {
            isTwoUp ? (width = 0.70) : (width = 0.50); 
        }
        else {
            isTwoUp ? (width = 1.0) : (width = 0.95);
        }
        
        return Math.floor( flowingWrapperWidth * width );
    },

    // Rationale: on iOS frames are automatically expanded to fit the content dom
    //   thus we cannot use relative size for the iframe and must set abs 
    //   pixel size
    setFrameSize : function (flowingWrapperWidth, flowingWrapperHeight, readiumFlowingContent, currentMargin, isTwoUp) {

        var width = this.getFrameWidth(flowingWrapperWidth, currentMargin, isTwoUp).toString() + "px";
        var height = flowingWrapperHeight.toString() + "px"; 

        // Rationale: Set the width for both the iframe (epub content) and its parent. The parent width must be provided so 
        //   that the iframe content can be centered within it, using CSS (margin-left/right: auto; display:block)
        $(readiumFlowingContent).parent().css("width", width);
        $(readiumFlowingContent).parent().css("height", height);

        $(readiumFlowingContent).css("width", width);
        $(readiumFlowingContent).css("height", height);
    },

    getBodyColumnCss : function () {

        var css = {};
        css[this.getColumnAxisCssName()] = "horizontal";
        css[this.getColumnGapCssName()] = this.gap_width.toString() + "px";
        css[this.getColumnWidthCssName()] = this.page_width.toString() + "px";
        css["position"] = "absolute";
        css["width"] = this.page_width.toString() + "px";
        css["height"] = this.frame_height.toString() + "px";
        return css;
    },

    // Description: This method accounts for the case in which the page-spread-* property is set on the current 
    //   content document. When this property is set, it requires that the first page of content is offset by 1, 
    //   creating a blank page as the first page in a synthetic spread.
    accountForOffset : function (readiumFlowingContent, isTwoUp, firstPageIsOffset, currentPages, ppd) {

        var $reflowableIframe = $(readiumFlowingContent);

        if (isTwoUp) {
            // If the first page is offset, adjust the window to only show one page
            var firstPageIsOffset = firstPageIsOffset;
            var firstPageOffsetValue;

            // Rationale: A current page of [0, 1] indicates that the current display is synthetic, and that 
            //   only the first page should be showing in that display
            var onFirstPage = 
                currentPages[0] === 0 &&
                currentPages[1] === 1 
                ? true : false;

            if (firstPageIsOffset && onFirstPage) {

                if (ppd === "rtl") {

                    firstPageOffset = -(this.page_width + this.gap_width);
                    $reflowableIframe.css("margin-left", firstPageOffset + "px");
                }
                // Left-to-right pagination
                else {

                    firstPageOffset = this.page_width + (this.gap_width * 2) - this.padding_width;
                    $reflowableIframe.css("margin-left", firstPageOffset + "px");
                }

                return 1;
            }
            else {

                $reflowableIframe.css("margin-left", "0px");
                return currentPages[0];
            }
        }
        else {

            $reflowableIframe.css("margin-left", "0px");
            return currentPages[0];
        }
    },

    // REFACTORING CANDIDATE: There is a very important assumption encoded in this method: That the direct parent of the "flowingWrapper"
    //   element will be the "reader" element in the DOM in which EPUB content is being displayed. The height and width of this parent are
    //   used to paginate the reflowable content document. This assumption should be made clearer - in fact, this whole model needs to get
    //   refactored at some point. 
    adjustIframeColumns : function (offsetDir, epubContentDocument, readiumFlowingContent, flowingWrapper, isTwoUp, firstPageOffset, currentPages, ppd, currentMargin ) {

        var prop_dir = offsetDir;
        var $frame = $(readiumFlowingContent);
        var page;

        // Rationale: Get width and height of the flowing wrapper parent, as the (application-specific) parent element dimensions are what the epub
        //   content should be sized to fit into.
        this.setFrameSize($(flowingWrapper).parent().width(), $(flowingWrapper).parent().height(), readiumFlowingContent, currentMargin, isTwoUp);

        this.frame_width = parseInt($frame.width(), 10);
        this.frame_height = parseInt($frame.height(), 10);
        this.gap_width = Math.floor(this.frame_width / 10);
        this.padding_width = Math.floor(this.gap_width / 2);

        if (isTwoUp) {
            this.page_width = Math.floor((this.frame_width - this.gap_width - (this.padding_width * 2)) / 2);
        }
        else {
            this.page_width = Math.floor(this.frame_width - (this.padding_width * 2));
        }

        // it is important for us to make sure there is no padding or
        // margin on the <html> elem, or it will mess with our column code
        $(epubContentDocument).css( this.getBodyColumnCss() );
        $(readiumFlowingContent).css("width", this.frame_width - this.padding_width - this.padding_width);
        $(readiumFlowingContent).css("padding-left", this.padding_width);
        $(readiumFlowingContent).css("padding-right", this.padding_width);

        page = this.accountForOffset(readiumFlowingContent, isTwoUp, firstPageOffset, currentPages, ppd);
        return page;
    },

    setFontSize : function (fontSize, epubContentDocument, isTwoUp) {

        var size = fontSize / 10;
        $(epubContentDocument).css("font-size", size + "em");

        // the content size has changed so recalc the number of 
        // pages
        return this.calcNumPages(epubContentDocument, isTwoUp);
    }
});
    EpubReflowable.Trigger = function(domNode) {
	var $el = $(domNode);
	this.action 	= $el.attr("action");
	this.ref 		= $el.attr("ref");
	this.event 		= $el.attr("ev:event");
	this.observer 	= $el.attr("ev:observer");
	this.ref 		= $el.attr("ref");
};

EpubReflowable.Trigger.prototype.subscribe = function(dom) {
	var selector = "#" + this.observer;
	var that = this;
	$(selector, dom).on(this.event, function() {
		that.execute(dom);
	});
};

EpubReflowable.Trigger.prototype.execute = function(dom) {
	var $target = $( "#" + this.ref, dom);
	switch(this.action)
	{
	case "show":
	  $target.css("visibility", "visible");
	  break;
	case "hide":
	  $target.css("visibility", "hidden");
	  break;
	case "play":
	  $target[0].currentTime = 0;
	  $target[0].play();
	  break;
	case "pause":
	  $target[0].pause();
	  break;
	case "resume":
	  $target[0].play();
	  break;
	case "mute":
	  $target[0].muted = true;
	  break;
	case "unmute":
	  $target[0].muted = false;
	  break;
	default:
	  console.log("do not no how to handle trigger " + this.action);
	}
};
    EpubReflowable.ReflowablePaginationView = Backbone.View.extend({

    el : "<div class='flowing-wrapper clearfix' style='display:block;margin-left:auto;margin-right:auto;position:relative;overflow:hidden;'> \
            <iframe scrolling='no' \
                    frameborder='0' \
                    height='100%' \
                    class='readium-flowing-content'> \
            </iframe> \
          </div>",

	initialize : function (options) {

        var ViewerModel = Backbone.Model.extend({});
        var SpineItemModel = Backbone.Model.extend({});

        this.viewerModel = new ViewerModel(options.viewerSettings);
        this.viewerModel.set({ syntheticLayout : options.viewerSettings.syntheticLayout });
        this.spineItemModel = new SpineItemModel(options.spineItem);
        this.epubCFIs = options.contentDocumentCFIs;
        this.bindings = options.bindings;

		// Initalize delegates and other models
		this.reflowableLayout = new EpubReflowable.ReflowableLayout();
		this.reflowablePaginator = new EpubReflowable.ReflowablePaginator();
		this.reflowableElementsInfo = new EpubReflowable.ReflowableElementInfo();
		this.pages = new EpubReflowable.ReflowablePagination();

        // Initialize custom style views
        this.spineDivider = new EpubReflowable.ReflowableSpineDividerView();
        this.$el.append(this.spineDivider.render());
        this.customizer;

		this.annotations;
        this.cfi = new EpubCFIModule();
	},
	
	destruct : function() {},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	render : function (goToLastPage, hashFragmentId) {

		var that = this;
		var json = this.spineItemModel.toJSON();

        $("iframe", this.el).attr("src", json.contentDocumentURI);
        $("iframe", this.el).attr("title", json.title);

		// Wait for iframe to load EPUB content document
		$(this.getReadiumFlowingContent()).on("load", function (e) {

            // "Forward" the epubReadingSystem object to the iframe's own window context.
            // Note: the epubReadingSystem object may not be ready when directly using the
            // window.onload callback function (from within an (X)HTML5 EPUB3 content document's Javascript code)
            // To address this issue, the recommended code is:
            // -----
            // function doSomething() { console.log(navigator.epubReadingSystem); };
            // 
            // // With jQuery:
            // $(document).ready(function () { setTimeout(doSomething, 200); });
            // 
            // // With the window "load" event:
            // window.addEventListener("load", function () { setTimeout(doSomething, 200); }, false);
            // 
            // // With the modern document "DOMContentLoaded" event:
            // document.addEventListener("DOMContentLoaded", function(e) { setTimeout(doSomething, 200); }, false);
            // -----
            if (typeof navigator.epubReadingSystem != 'undefined')
            {
               var iFrame = that.getReadiumFlowingContent();
               var iFrameWindow = iFrame.contentWindow || iFrame.contentDocument.parentWindow;
               var ers = navigator.epubReadingSystem;
               iFrameWindow.navigator.epubReadingSystem = ers;
            }

            var borderElement;
			that.initializeContentDocument();

			// Rationale: The content document must be paginated in order for the subsequent "go to page" methods
			//   to have access to the number of pages in the content document.
			that.paginateContentDocument();
			// that.mediaOverlayController.pagesLoaded();

			// Rationale: The assumption here is that if a hash fragment is specified, it is the result of Readium 
			//   following a clicked linked, either an internal link, or a link from the table of contents. The intention
			//   to follow a link should supersede restoring the last-page position, as this should only be done for the 
			//   case where Readium is re-opening the book, from the library view. 
			if (hashFragmentId) {
                that.showPageByElementId(hashFragmentId);
            }
            else {

                if (goToLastPage) {
                    // that.pages.goToLastPage(that.viewerModel.get("syntheticLayout"), that.spineItemModel.get("firstPageIsOffset"));
                }
                else {
                    that.showPageByNumber(1);
                    // that.pages.goToPage(1, that.viewerModel.get("syntheticLayout"), that.spineItemModel.get("firstPageIsOffset"));
                }
            }

            that.annotations = new EpubAnnotationsModule(
                that.getEpubContentDocument().parentNode,
                that
            );

            that.customizer = new EpubReflowable.ReflowableCustomizer({
                parentElement : that.getFlowingWrapper(),
                readiumFlowingContent : that.getReadiumFlowingContent(),
                spineDividerStyleView : that.spineDivider,
                epubContentDocument : that.getEpubContentDocument()
            });

            that.trigger("contentDocumentLoaded", that.el);
		});
        
		return this.el;
	},

    showPageByNumber : function (pageNumber) {

        this.pages.goToPage(pageNumber, this.viewerModel.get("syntheticLayout"), this.spineItemModel.get("firstPageIsOffset"));
        this.showCurrentPages();
    },

    // TODO: Check to see if it's a character offset CFI. If it is, inject it and keep track of the injection.
    showPageByCFI : function (CFI) {

        var $rangeTargetElements;
        var $standardTargetElement;
        var targetElement;
        try {

            // Check if it's a CFI range type
            if (new RegExp(/.+,.+,.+/).test(CFI)) {
                $rangeTargetElements = this.cfi.getRangeTargetElements(
                    CFI, 
                    $(this.getEpubContentDocument()).parent()[0],
                    [],
                    [],
                    ["MathJax_Message"]
                );
                targetElement = $rangeTargetElements[0];
            }
            else {
                $standardTargetElement = this.cfi.getTargetElement(
                    CFI,
                    $(this.getEpubContentDocument()).parent()[0],
                    [],
                    [],
                    ["MathJax_Message"]
                );
                targetElement = $standardTargetElement[0];
            }
        }
        catch (error) {
            // Maybe check error type
            throw error;
        }

        if (targetElement.nodeType === Node.TEXT_NODE) {
            this.showPageByElement($(targetElement).parent()[0])
        }
        else {
            this.showPageByElement(targetElement);
        }
    },

    showPageByElementId : function (elementId) {

        var targetElement = $("#" + elementId, this.getEpubContentDocument())[0];
        if (!targetElement) {
            return;
        }

        // Rationale: We get more precise results if we look at the first children
        while (targetElement.children.length > 0) {
            targetElement = targetElement.children[0];
        }

        this.showPageByElement(targetElement);
    },

    showView : function () {
        
        this.$el.show();
        this.updatePageNumber();
    },

    hideView : function () {
        
        this.$el.hide();
    },

    // REFACTORING CANDIDATE: This method is delegating to setFontSize and setMargin. These could both be added 
    //   as customizable style objects - essentially treated the same way
    customizeStyles : function (customElement, styleNameOrCSSObject) {

        if (customElement === "margin") {
            this.setMargin(parseInt(styleNameOrCSSObject));
        }
        else if (customElement === "fontSize") {
            this.setFontSize(parseInt(styleNameOrCSSObject));
        }
        else {
            this.customizer.setCustomStyle(customElement, styleNameOrCSSObject);
        }
        this.paginateContentDocument();
    },

    setFontSize : function (fontSize) {

        if (fontSize !== this.viewerModel.get("fontSize")) {
            this.viewerModel.set("fontSize", fontSize);
            this.paginateContentDocument();    
        }
    },

    setMargin : function (margin) {

        if (margin !== this.viewerModel.get("currentMargin")) {
            this.viewerModel.set("currentMargin", margin);
            this.paginateContentDocument();
        }
    },

    setSyntheticLayout : function (isSynthetic) {
    
        // Rationale: Only toggle the layout if a change is required        
        if (isSynthetic !== this.viewerModel.get("syntheticLayout")) {

            this.viewerModel.set("syntheticLayout", isSynthetic);
            this.pages.toggleTwoUp(isSynthetic, this.spineItemModel.get("firstPageIsOffset"));
            this.paginateContentDocument();
            this.viewerModel.get("syntheticLayout") ? this.spineDivider.show() : this.spineDivider.hide();
            this.trigger("layoutChanged", isSynthetic);
        }
    },

    nextPage : function () {

        if (!this.pages.onLastPage()) {

            var isSynthetic = this.viewerModel.get("syntheticLayout");
            this.pages.nextPage(isSynthetic);
            this.showCurrentPages();

            // Trigger events
            this.trigger("atNextPage");
            this.pages.onLastPage() ? this.trigger("atLastPage") : undefined;
        } 
        else {
            this.trigger("atLastPage");
        }
    },

    previousPage : function () {

        if (!this.pages.onFirstPage()) {

            var isSynthetic = this.viewerModel.get("syntheticLayout");
            this.pages.prevPage(isSynthetic);
            this.showCurrentPages();

            // Trigger events
            this.trigger("atPreviousPage");
            this.pages.onFirstPage() ? this.trigger("atFirstPage") : undefined; 
        }
        else {
            this.trigger("atFirstPage");
        }
    },

	// ------------------------------------------------------------------------------------ //
	//  PRIVATE GETTERS FOR VIEW                                                            //
	// ------------------------------------------------------------------------------------ //    

	getFlowingWrapper : function () {
		return this.el;
	},

	getReadiumFlowingContent : function () {
		return $(this.el).children()[0];
	},

    // REFACTORING CANDIDATE: That's a lot of chaining right there. Too much. 
	getEpubContentDocument : function () {
		return $($($(this.el).children()[0]).contents()[0]).children()[0];
	},

	// ------------------------------------------------------------------------------------ //
	//  PRIVATE EVENT HANDLERS                               								//
	// ------------------------------------------------------------------------------------ //

	keydownHandler : function (e) {

        if (e.which == 39) {
            this.trigger("keydown-right");
        }
                        
        if (e.which == 37) {
            this.trigger("keydown-left");
        }
    },

    linkClickHandler : function (e) {

        this.trigger("epubLinkClicked", e);
    },

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS AND UTILITY METHODS                                               //
	// ------------------------------------------------------------------------------------ //

    // Rationale: The "paginator" model uses the scrollWidth of the paginated xhtml content document in order
    //   to calculate the number of pages (given the current screen size etc.). It appears that 
    //   the scroll width property is either buggy, unreliable, or changes by small amounts between the time the content
    //   document is paginated and when it is used. Regardless of the cause, the scroll width is understated, which causes
    //   the number of pages to be understated. As a result, the last page of a content document is often not shown when 
    //   a user moves to the last page of the content document. This method recalculates the number of pages for the current
    //   scroll width of the content document. 
    updatePageNumber : function () {
        
        var recalculatedNumberOfPages;
        var epubContentDocument = this.getEpubContentDocument();
        var isSyntheticLayout = this.viewerModel.get("syntheticLayout");
        var currScrollWidth = epubContentDocument.scrollWidth;
        var lastScrollWidth = this.reflowablePaginator.get("lastScrollWidth");

        if (lastScrollWidth !== currScrollWidth) {
            recalculatedNumberOfPages = this.reflowablePaginator.calcNumPages(epubContentDocument, isSyntheticLayout);
            this.pages.set("numberOfPages", recalculatedNumberOfPages);
            this.reflowablePaginator.set("lastScrollWidth", currScrollWidth);
        }
    },

	// Rationale: This method delegates the pagination of a content document to the reflowable layout model
	paginateContentDocument : function () {

		var pageInfo = this.reflowablePaginator.paginateContentDocument(
			this.viewerModel.get("syntheticLayout"),
			this.offsetDirection(),
			this.getEpubContentDocument(),
			this.getReadiumFlowingContent(),
			this.getFlowingWrapper(),
			this.spineItemModel.get("firstPageIsOffset"),
			this.pages.get("currentPages"),
			this.spineItemModel.get("pageProgressionDirection"),
			this.viewerModel.get("currentMargin"),
			this.viewerModel.get("fontSize")
		);

		this.pages.set("numberOfPages", pageInfo[0]);
        this.viewerModel.get("syntheticLayout") ? this.spineDivider.show() : this.spineDivider.hide();
        this.redrawAnnotations();
        this.pages.resetCurrentPages();
		this.showCurrentPages();
	},

	initializeContentDocument : function () {

		this.reflowableLayout.initializeContentDocument(
			this.getEpubContentDocument(),
			this.getReadiumFlowingContent(), 
			this.linkClickHandler, 
			this, 
			this.keydownHandler,
            this.bindings
		);
	},

    showPageByElement : function (element) {

        var pageNumber = this.reflowableElementsInfo.getElemPageNumber(
            element, 
            this.offsetDirection(), 
            this.reflowablePaginator.page_width, 
            this.reflowablePaginator.gap_width,
            this.getEpubContentDocument());

        if (pageNumber > 0) {

            this.pages.goToPage(pageNumber, this.viewerModel.get("syntheticLayout"), this.spineItemModel.get("firstPageIsOffset"));
            this.showCurrentPages();
        }
        else {
            // Throw an exception here 
        }
    },

    showCurrentPages : function () {

        var currentPageNumber;
        this.hideContent();
        currentPageNumber = this.reflowablePaginator.accountForOffset(
            this.getReadiumFlowingContent(),
            this.viewerModel.get("syntheticLayout"),
            this.spineItemModel.get("firstPageIsOffset"),
            this.pages.get("currentPages"),
            this.spineItemModel.get("pageProgressionDirection")
        );
        this.moveViewportToPage(currentPageNumber);
        this.showContent();
        this.trigger("displayedContentChanged");
    },

    moveViewportToPage : function (pageNumber) {

        var offset = this.calcPageOffset(pageNumber).toString() + "px";
        $(this.getEpubContentDocument()).css(this.offsetDirection(), "-" + offset);
    },

	hideContent : function () {
		$(this.getFlowingWrapper()).css("opacity", "0");
	},

	showContent : function () {
		$(this.getFlowingWrapper()).css("opacity", "1");
	},

	calcPageOffset : function (pageNumber) {
		return (pageNumber - 1) * (this.reflowablePaginator.page_width + this.reflowablePaginator.gap_width);
	},

    redrawAnnotations : function () {

        if (this.annotations) {
            this.annotations.redraw();
        }
    },

	offsetDirection : function () {

		// Rationale: If this book does right to left pagination we need to set the
		//   offset on the right
		if (this.spineItemModel.get("pageProgressionDirection") === "rtl") {
			return "right";
		}
		else {
			return "left";
		}
	}
});
    EpubReflowable.ReflowableCustomizer = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.$parentEl = $(this.get("parentElement"));
        this.set("customBorder", new EpubReflowable.ReflowableCustomBorder({ targetElement : this.get("readiumFlowingContent") }));
        this.set("customTheme", new EpubReflowable.ReflowableCustomTheme({ iframeElement : this.get("readiumFlowingContent") }));
    },

    // ----- PUBLIC INTERFACE -------------------------------------------------------------------

    setCustomStyle : function (customProperty, styleNameOrCSS) {

        if (customProperty === "reflowable-epub-border" || customProperty === "epub-border") {
            this.get("customBorder").setCurrentStyle(styleNameOrCSS);
        }
        else if (customProperty === "reflowable-spine-divider" || customProperty === "spine-divider") {
            this.get("spineDividerStyleView").setCurrentStyle(styleNameOrCSS);
        }
        else if (customProperty === "reflowable-page-border" || customProperty === "page-border") {
            this.get("customBorder").setCurrentStyle(styleNameOrCSS);
            this.get("spineDividerStyleView").setCurrentStyle(styleNameOrCSS);
        }
        else if (customProperty === "reflowable-page-theme") {
            this.get("customTheme").setCurrentStyle(styleNameOrCSS);
        }
        else if (customProperty === "alt-style-tag") {
            this.get("customTheme").setAlternateStyleTag(styleNameOrCSS, this.get("epubContentDocument"));
        }
    }

    // ----- PRIVATE HELPERS -------------------------------------------------------------------
});
    EpubReflowable.ReflowableCustomBorder = Backbone.Model.extend({

    // ------ PUBLIC INTERFACE --------------------------------------------------------------

    initialize : function (attributes, options) {

        this.$element = $(this.get("targetElement"));
        this.currentStyle = {};

        if (this.get("customStyle")) {
            this.setCurrentStyle(this.get("customStyle"));
        }
        else {
            this.setCurrentStyle("none");
        }
    },

    setCurrentStyle : function (styleNameOrCSSObject) {

        var borderStyle;
        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            borderStyle = this.getDefaultBorderStyle(styleNameOrCSSObject);

            if (borderStyle !== undefined) {
                this.currentStyle = borderStyle;
                this.renderCurrentStyle();
            }
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            borderStyle = this.addRequiredPositionCSS(styleNameOrCSSObject);
            this.currentStyle = borderStyle;
            this.renderCurrentStyle();
        }
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function () {

        this.$element.attr("style", "");
        this.$element.css(this.currentStyle);
    },

    getDefaultBorderStyle : function (defaultName) {

        var defaultCSS;
        if (defaultName === "box-shadow") {
            return this.addRequiredPositionCSS({ "box-shadow" : "0 0 5px 5px rgba(80, 80, 80, 0.5)" });
        }
        else if (defaultName == "none") {
            return this.addRequiredPositionCSS({});
        }
        else {
            return undefined;
        }
    },

    addRequiredPositionCSS : function (customCSS) {

        var positionCSS = {
            "position" : "relative",
            "z-index" : "0",
            "top" : "0px",
            "left" : "0px",
            "width" : "100%",
            "height" : "100%"
        };

        // Rationale: The underscore.js extend method will combine two (or more) objects. However, any properties in the second
        //   object will overwrite the same properties in the first object. This is desired, as the position properties must be 
        //   specified as defined in this view. 
        var customCSSWithPositionCSS = _.extend(customCSS, positionCSS);
        return customCSSWithPositionCSS;
    }
});
    EpubReflowable.ReflowableSpineDividerView = Backbone.View.extend({

    el : "<div class='reflowing-spine-divider'></div>",

    // ------ PUBLIC INTERFACE --------------------------------------------------------------

    initialize : function (options) {

        this.currentStyle = {};

        if (options && options.customStyle) {
            this.setCurrentStyle(options.customStyle);
        }
        else {
            this.setCurrentStyle("none");
        }
    },  

    render : function () {

        this.renderCurrentStyle();
        return this.el;
    },

    setCurrentStyle : function (styleNameOrCSSObject) {

        var spineStyle;
        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            spineStyle = this.getDefaultSpineStyle(styleNameOrCSSObject);

            if (spineStyle !== undefined) {
                this.currentStyle = spineStyle;
                this.renderCurrentStyle();
            }
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            spineStyle = this.addRequiredPositionCSS(styleNameOrCSSObject);
            this.currentStyle = spineStyle;
            this.renderCurrentStyle();
        }
    },

    hide : function () {
        this.$el.hide();
    },

    show : function () {
        this.$el.show();
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function () {

        this.$el.attr("style", "");
        this.$el.css(this.currentStyle);
    },

    getDefaultSpineStyle : function (defaultName) {

        var defaultCSS;
        if (defaultName === "box-shadow") {
            return this.addRequiredPositionCSS({
                "width" : "1px",
                "height" : "93%",
                "top" : "3%",
                "box-shadow" : "0 0 5px 5px rgba(80, 80, 80, 0.5)" 
            });
        }
        else if (defaultName === "none") {
            return this.addRequiredPositionCSS({});
        }
        else {
            return undefined;
        }
    },

    addRequiredPositionCSS : function (customCSS) {

        var top = customCSS.top ? customCSS.top : "0px";
        var positionCSS = {
            "position" : "absolute",
            "z-index" : "2",
            "left" : "50%",
            "top" : top
        };

        // Rationale: The underscore.js extend method will combine two (or more) objects. However, any properties in the second
        //   object will overwrite the same properties in the first object. This is desired, as the position properties must be 
        //   specified as defined in this view. 
        var customCSSWithPositionCSS = _.extend(customCSS, positionCSS);
        return customCSSWithPositionCSS;
    }
});
    
// TODO: Need to check that if alternate styles are defined for night, they are respected
EpubReflowable.ReflowableCustomTheme = Backbone.Model.extend({

    // ------ PUBLIC INTERFACE --------------------------------------------------------------

    initialize : function (attributes, options) {

        this.currentStyle = {};
    },

    setCurrentStyle : function (styleNameOrCSSObject) {

        var themeStyle;
        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            themeStyle = this.getDefaultThemeStyle(styleNameOrCSSObject);

            if (themeStyle !== undefined) {

                this.currentStyle = themeStyle;
                this.renderCurrentStyle();
            }
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            themeStyle = styleNameOrCSSObject;
            this.currentStyle = themeStyle;
            this.renderCurrentStyle();
        }
    },

    // Description: Activates a style set for the ePub, based on the currently selected theme. At present, 
    //   only the day-night alternate tags are available as an option.  
    setAlternateStyleTag : function (themeName, epubContentDocument) {

        var selector = new EpubReflowable.AlternateStyleTagSelector();        
        if (themeName === "night") {
            selector.activateAlternateStyleSet(["night"], epubContentDocument);
        }
        else if (themeName === "day" || themeName === "none") {
            selector.activateAlternateStyleSet(["day"], epubContentDocument);
        }
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function () {

        $(this.getContentDocumentHTML()).attr("style", "");
        $(this.getContentDocumentHTML()).css(this.currentStyle);
    },

    getDefaultThemeStyle : function (defaultName) {

        if (defaultName === "none") {
            return {
                "background-color": "white",
                "color": "black",
                "mo-color": "#777"
            };
        }
        else if (defaultName === "vancouver") {
            return {
                "background-color": "#DDD",
                "color": "#576b96",
                "mo-color": "#777"
            };   
        }
        else if (defaultName === "night") {
            return {
                "background-color": "#141414",
                "color": "white",
                "mo-color": "#666"
            };
        }
        else if (defaultName === "ballard") {
            return {
                "background-color": "#576b96",
                "color": "#DDD",
                "mo-color": "#888"
            };
        }
        else {
            return undefined;
        }
    },

    getContentDocumentHTML : function () {

        return $("body", this.get("iframeElement").contentDocument)[0];
    }
});

    var reflowableView = new EpubReflowable.ReflowablePaginationView({
        spineItem : spineObject,
        viewerSettings : viewerSettingsObject,
        contentDocumentCFIs : CFIAnnotations,
        bindings : bindings
    });

    // Description: The public interface
    return {

        render : function (goToLastPage, hashFragmentId) {
            return reflowableView.render(goToLastPage, hashFragmentId);
        },
        nextPage : function () {
            return reflowableView.nextPage();
        },
        previousPage : function () {
            return reflowableView.previousPage();
        },
        showPageByHashFragment : function (hashFragmentId) {
            return reflowableView.showPageByElementId(hashFragmentId);
        },
        showPageByNumber : function (pageNumber) {
            return reflowableView.showPageByNumber(pageNumber);
        },
        showPageByCFI : function (CFI) {
            return reflowableView.showPageByCFI(CFI);
        },
        numberOfPages : function () {
            return reflowableView.pages.get("numberOfPages");
        },
        currentPage : function () {
            return reflowableView.pages.get("currentPages");
        },
        onFirstPage : function () {
            return reflowableView.pages.onFirstPage();
        },
        onLastPage : function () {
            return reflowableView.pages.onLastPage();
        },
        showPagesView : function () {
            return reflowableView.showView();
        },
        hidePagesView : function () {
            return reflowableView.hideView();
        },
        setSyntheticLayout : function (isSynthetic) {
            return reflowableView.setSyntheticLayout(isSynthetic);
        },
        on : function (eventName, callback, callbackContext) {
            return reflowableView.on(eventName, callback, callbackContext);
        },
        off : function (eventName, callback) {
            return reflowableView.off(eventName, callback);
        },
        resizeContent : function () {
            return reflowableView.paginateContentDocument();
        },
        customize : function (customElement, styleNameOrCSSObject) {
            reflowableView.customizeStyles(customElement, styleNameOrCSSObject);
            return this;
        },
        addSelectionHighlight : function (id, type) { 
            return reflowableView.annotations.addSelectionHighlight(id, type); 
        },
        addSelectionBookmark : function (id) { 
            return reflowableView.annotations.addSelectionBookmark(id); 
        },
        addSelectionImageAnnotation : function (id) {
            return reflowableView.annotations.addSelectionImageAnnotation(id);
        },
        addHighlight : function (CFI, id, type) { 
            return reflowableView.annotations.addHighlight(CFI, id, type); 
        },
        addBookmark : function (CFI, id) { 
            return reflowableView.annotations.addBookmark(CFI, id); 
        },
        addImageAnnotation : function (CFI, id) { 
            return reflowableView.annotations.addImageAnnotation(CFI, id); 
        }
    };
};

    var EpubFixedModule = function (spineObjects, viewerSettingsObject) {

    var EpubFixed = {};

    // Rationale: The order of these matters
    // Description: This model is responsible determining page numbers to display for fixed layout EPUBs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer. The logic for this is reasonably complex, as there a number of different factors that must be
//   taken into account in various cases. These include: The page progression direction, 
//   the reading order of pages, the number of pages displayed on the screen, and author preferences 
//   for the location of pages (left/right/center). 

EpubFixed.PageNumberDisplayLogic = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize : function () {},

    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //   pageProgressionDirection ("rtl" or "ltr): The page progression direction
    //	)
	getPageNumbers : function (gotoPageNumber, twoUp, pageProgressionDirection) {

		if (twoUp) {
			
			if (pageProgressionDirection === "rtl") {

				if (this.pageIsLeft(gotoPageNumber)) {

					if (this.pageIsRight(gotoPageNumber - 1)) {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {
						return [gotoPageNumber];
					}
				}
				else if (this.pageIsRight(gotoPageNumber)) {

					if (this.pageIsLeft(gotoPageNumber + 1)) {
						return [gotoPageNumber, gotoPageNumber + 1];	
					}
					else {
						return [gotoPageNumber];
					}
				}
				// A center page
				else {
					return [gotoPageNumber];
				}
			}
			// Left-to-right page progression
			else {

				if (this.pageIsLeft(gotoPageNumber)) {

					if (this.pageIsRight(gotoPageNumber + 1)) {
						return [gotoPageNumber, gotoPageNumber + 1];
					}
					else {
						return [gotoPageNumber];
					}
				}
				else if (this.pageIsRight(gotoPageNumber)) {

					if (this.pageIsLeft(gotoPageNumber - 1)) {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {
						return [gotoPageNumber];
					}
				}
				// A center page
				else {
					return [gotoPageNumber];
				}
			}
		}
		else {	
			return [gotoPageNumber];
		}
	},

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	getPreviousPageNumbers : function (currentPages, twoUp, pageProgressionDirection) {

		var curr_pg = currentPages;
		var lastPage = curr_pg[0] - 1;

		// Single page navigation
		if (!twoUp){
			return [lastPage];
		}
		else if (pageProgressionDirection === "rtl") {

			// If the first page is a left page in rtl progression, only one page 
			// can be displayed, even in two-up mode
			if (this.pageIsLeft(lastPage) && 
				this.pageIsRight(lastPage - 1)) {

				return [lastPage - 1, lastPage];
			}
			else {

				return [lastPage];
			}
		}
		// Left-to-right progresion
		else {

			if (this.pageIsRight(lastPage) &&
				this.pageIsLeft(lastPage - 1)) {

				return [lastPage - 1, lastPage];
			}
			else {

				return [lastPage];
			}
		}
	},

	// Description: Get the pages to display when moving in reading order
    // Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	getNextPageNumbers : function (currentPages, twoUp, pageProgressionDirection) {

		var curr_pg = currentPages;
		var firstPage = curr_pg[curr_pg.length - 1] + 1;

		if (!twoUp) {
			return [firstPage];
		}
		else if (pageProgressionDirection === "rtl") {

			// If the first page is a left page in rtl progression, only one page 
			// can be displayed, even in two-up mode
			if (this.pageIsRight(firstPage) &&
				this.pageIsLeft(firstPage + 1)) {

				return [firstPage, firstPage + 1];
			}
			else {

				return [firstPage];
			}
		}
		else {

			if (this.pageIsLeft(firstPage) && 
				this.pageIsRight(firstPage + 1)) {

				return [firstPage, firstPage + 1];
			}
			else {

				return [firstPage];
			}
		}
	},

	// Description: This method determines which page numbers to display when switching
	//   between a single page and side-by-side page views and vice versa.
	// Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	// Notes: Authors can specify a fixed layout page as a "center" page, which prevents more than one page
	//   being displayed. This case is not handled yet.
	getPageNumbersForTwoUp : function (currentPages, twoUp, pageProgressionDirection) {

		var displayed = currentPages;
		var twoPagesDisplayed = displayed.length === 2 ? true : false;
		var newPages = [];

		// Two pages are currently displayed; find the single page number to display
		if (twoPagesDisplayed) {

			// Rationale: I think this check is a bit of a hack, for the case in which a set of pages is [0, 1]. Pages are
			//   1-indexed, so the "0" in the 0 index position of the array is not valid.
			if (displayed[0] === 0) {
				
				newPages[0] = 1;
			} 
			else {
				
				newPages[0] = displayed[0];
			}
		}
		// A single fixed layout page is displayed
		else {

			// page progression is right-to-left
			if (pageProgressionDirection === "rtl") {

				// and the previous one is right, then display both, otherwise, just display one
				if (this.pageIsLeft(displayed[0])) {
					
					if (this.pageIsRight(displayed[0] - 1)) {

						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// if the next page is left, display both, otherwise, just display one
				else if (this.pageIsRight(displayed[0])) {
					
					if (this.pageIsLeft(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
			// page progression is left-to-right
			else {

				// If next page is a right page, display both, otherwise just display this one
				if (this.pageIsLeft(displayed[0])) {
					
					if (this.pageIsRight(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				else if (this.pageIsRight(displayed[0])) {
					
					if (this.pageIsLeft(displayed[0] - 1)) {
						
						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
		}

		return newPages;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: The `displayedPageIs...` methods determine if a fixed layout page is right, left or center.
	pageIsRight : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "right") {
			return true;
		}
		else {
			return false;
		}
	},

	pageIsLeft : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "left") {
			return true;
		}
		else {
			return false;
		}
	},

	pageIsCenter : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "center") {
			return true;
		}
		else {
			return false;
		}
	}
});
    EpubFixed.FixedPageViews = Backbone.Model.extend({

    defaults : function () {

        return {
            "fixedPages" : [],
            "currentPages" : [1],
        }
    },

    // -------------------------------------------- PUBLIC INTERFACE ---------------------------------

    initialize : function (attributes, options) {

        this.fixedPagination = new EpubFixed.PageNumberDisplayLogic({ spineObjects : this.get("spineObjects") });

        // Rationale: Get the page progression direction off the first spine object. This assumes that ppd is the 
        //   same for all FXL spine objects in the epub - which it should be. 
        this.set("pageProgressionDirection", this.get("spineObjects")[0].pageProgressionDirection);
    },

    renderFixedPages : function (bindingElement, viewerSettings, linkClickHandler, handlerContext) {

        // Reset the default for a synthetic layout
        if (viewerSettings.syntheticLayout) {
            this.set("currentPages", [1, 2]);
        }

        this.loadPageViews(viewerSettings);
        this.renderAll(bindingElement, linkClickHandler, handlerContext, viewerSettings.syntheticLayout);
    },

    nextPage : function (twoUp, pageSetEventContext) {

        var newPageNums;
        if (!this.onLastPage()) {

            newPageNums = this.fixedPagination.getNextPageNumbers(this.get("currentPages"), twoUp, this.get("pageProgressionDirection"));
            this.resetCurrentPages(newPageNums);

            // Trigger events
            pageSetEventContext.trigger("atNextPage");
            pageSetEventContext.trigger("displayedContentChanged");
            this.onLastPage() ? pageSetEventContext.trigger("atLastPage") : undefined;
        }
        else {
            pageSetEventContext.trigger("atLastPage");
        }
    },

    previousPage : function (twoUp, pageSetEventContext) {

        var newPageNums;
        if (!this.onFirstPage()) {

            newPageNums = this.fixedPagination.getPreviousPageNumbers(this.get("currentPages"), twoUp, this.get("pageProgressionDirection"));
            this.resetCurrentPages(newPageNums);
            
            // Trigger events
            pageSetEventContext.trigger("atPreviousPage");
            pageSetEventContext.trigger("displayedContentChanged");
            this.onFirstPage() ? pageSetEventContext.trigger("atFirstPage") : undefined;
        }
        else {
            pageSetEventContext.trigger("atFirstPage");
        }
    },

    onFirstPage : function () {

        if (this.get("currentPages")[0] <= 1) {
            return true;
        }

        return false;
    },

    onLastPage : function () {

        if (this.get("currentPages")[0]) {
            if (this.get("currentPages")[0] >= this.numberOfPages()) {
                return true;
            }
        }

        if (this.get("currentPages")[1]) {
            if (this.get("currentPages")[1] >= this.numberOfPages()) {
                return true;
            }
        }

        return false;
    },

    showPageNumber : function (pageNumber, syntheticLayout) {

        var pageIndexToShow;
        var fixedPageView;
        var pageNumsToShow = this.fixedPagination.getPageNumbers(pageNumber, syntheticLayout, this.get("pageProgressionDirection"));
        this.resetCurrentPages(pageNumsToShow);
    },

    setSyntheticLayout : function (isSynthetic) {

        var newPageNumbers;
        if (isSynthetic) {

            _.each(this.get("fixedPages"), function (fixedPageInfo) {
                fixedPageInfo.fixedPageView.setSyntheticPageSpreadStyle();
            });
        }
        else {

            _.each(this.get("fixedPages"), function (fixedPageInfo) {
                fixedPageInfo.fixedPageView.setSinglePageSpreadStyle();
            });
        }

        // Rationale: This method toggles the page numbers
        newPageNumbers = this.fixedPagination.getPageNumbersForTwoUp(this.get("currentPages"), undefined, this.get("pageProgressionDirection"));
        this.resetCurrentPages(newPageNumbers);
    },

    getPageViewInfo : function (pageNumber) {

        var pageIndex = pageNumber - 1;
        return this.get("fixedPages")[pageIndex];
    },

    // -------------------------------------------- PRIVATE HELPERS ---------------------------------

    hidePageViews : function () {

        _.each(this.get("fixedPages"), function (fixedPageInfo) {
            fixedPageInfo.fixedPageView.hidePage();
        });      
    },

    numberOfPages : function () {

        return this.get("fixedPages").length;
    },

    loadPageViews : function (viewerSettings) {

        var that = this;
        _.each(this.get("spineObjects"), function (spineObject) {

            var fixedPageView;
            var fixedPageViewInfo;
            if (spineObject.fixedLayoutType === "image") {
                fixedPageView = that.initializeImagePage(spineObject.pageSpread, spineObject.contentDocumentURI, viewerSettings);
            }
            // SVG and all others
            else {
                fixedPageView = that.initializeFixedPage(spineObject.pageSpread, spineObject.fixedLayoutType, spineObject.contentDocumentURI, viewerSettings);
            }

            // Create info object
            fixedPageViewInfo = {
                fixedPageView : fixedPageView,
                pageType : spineObject.fixedLayoutType,
                isRendered : false,
                spineIndex : spineObject.spineIndex,
                pageSpread : spineObject.pageSpread
            };

            that.get("fixedPages").push(fixedPageViewInfo);
        });
    },

    // REFACTORING CANDIDATE: the pageSetEventContext can be used to trigger the epubLoaded event; also, epubLoaded 
    //   should be renamed to something like pageSetLoaded.
    renderAll : function (bindingElement, linkClickHandler, handlerContext, isSynthetic) {

        var that = this;
        var numFixedPages = this.get("fixedPages").length;
        
        _.each(this.get("fixedPages"), function (fixedPageViewInfo) {

            fixedPageViewInfo.fixedPageView.on("contentDocumentLoaded", function (viewElement) { 

                fixedPageViewInfo.isRendered = true;
                fixedPageViewInfo.fixedPageView.hidePage();

                numFixedPages = numFixedPages - 1; 
                if (numFixedPages === 0) {
                    that.trigger("epubLoaded");
                }
            });
            
            that.addPageViewToDom(
                bindingElement, 
                fixedPageViewInfo.fixedPageView.render(
                    false, 
                    undefined, 
                    linkClickHandler, 
                    handlerContext,
                    isSynthetic
                )
            );
        });

        setTimeout(function () { 
            
            if (numFixedPages != 0) {
                // throw an exception
            }

        }, 1000);
    },

    addPageViewToDom : function (bindingElement, pageViewElement) {

        $(bindingElement).append(pageViewElement);
    },

    resetCurrentPages : function (currentPages) {

        this.set("currentPages", currentPages);
        this.hidePageViews();

        if (currentPages[0] !== undefined && currentPages[0] !== null) {
            this.getPageViewInfo(currentPages[0]).fixedPageView.showPage();
        }

        if (currentPages[1] !== undefined && currentPages[1] !== null) {
            this.getPageViewInfo(currentPages[1]).fixedPageView.showPage();
        }
    },

    initializeImagePage : function (pageSpread, imageSrc, viewerSettings) {

        return new EpubFixed.ImagePageView({
                        pageSpread : pageSpread,
                        imageSrc : imageSrc,
                        viewerSettings : viewerSettings
                    });
    },

    initializeFixedPage : function (pageSpread, fixedLayoutType, iframeSrc, viewerSettings) {

        return new EpubFixed.FixedPageView({
                        pageSpread : pageSpread,
                        fixedLayoutType : fixedLayoutType,
                        iframeSrc : iframeSrc,
                        viewerSettings : viewerSettings
                    });
    },

    resizePageViews : function (isSynthetic) {

        _.each(this.get("fixedPages"), function (fixedPageViewInfo) {
            fixedPageViewInfo.fixedPageView.setPageSize(isSynthetic);
        });
    }
});
    EpubFixed.FixedSizing = Backbone.Model.extend({

    initialize : function (attributes) {

        this.metaSize = { width : undefined, height : undefined };
        this.transformedPageSize = {};
    },

    // ------------------ PUBLIC INTERFACE ---------------------------------

    updateMetaSize : function () {

        var $img;
        var contentDocument = this.get("contentDocument");

        // first try to read viewport size
        var content = $('meta[name=viewport]', contentDocument).attr("content");

        // if not found try viewbox (used for SVG)
        if (!content) {
            content = $('meta[name=viewbox]', contentDocument).attr("content");
        }

        if (content) {
            var size = this.parseSize(content);
            if (size) {
                this.metaSize.width = size.width;
                this.metaSize.height = size.height;
            }
        }
        else { //try to get direct image size

            if ($(contentDocument).is("IMG")) {
                $img = $(contentDocument);
            }
            else {
                $img = $(contentDocument).find('img');
            }
            var width = $img.width();
            var height = $img.height();

            if (width > 0) {
                this.metaSize.width = width;
                this.metaSize.height = height;
            }
        }
    },

    fitToScreen : function (containerWidth, containerHeight, isSynthetic) {

        var bookSize = this.metaSize;
        if (bookSize.width == 0) {
            return;
        }

        var horScale = containerWidth / bookSize.width;
        var verScale = containerHeight / bookSize.height;
        if (isSynthetic) {
            horScale = horScale / 2;
        }

        var scale = Math.min(horScale, verScale);

        var css = this.generateTransformCSS(scale);

        this.transformedPageSize.width = Math.ceil(scale * bookSize.width);
        this.transformedPageSize.height = Math.ceil(scale * bookSize.height);
        css["width"] = bookSize.width;
        css["height"] = bookSize.height;

        return css;
    },

    // --------------------------- PRIVATE HELPERS -------------------------------------

    parseSize : function (content) {

        var pairs = content.replace(/\s/g, '').split(",");
        var dict = {};
        var width;
        var height;

        for (var i = 0; i < pairs.length; i++) {

            var nameVal = pairs[i].split("=");
            if (nameVal.length === 2) {
                dict[nameVal[0]] = nameVal[1];
            }
        }

        width = Number.NaN;
        height = Number.NaN;

        if (dict["width"]) {
            width = parseInt(dict["width"]);
        }

        if (dict["height"]) {
            height = parseInt(dict["height"]);
        }

        if (!isNaN(width) && !isNaN(height)) {
            return { 
                width : width, 
                height : height
            };
        }

        return undefined;
    },

    generateTransformCSS : function (scale) {

        var transformString = "scale(" + scale + ")";

        //modernizer library can be used to get browser independent transform attributes names (implemented in readium-web fixed_layout_book_zoomer.js)
        var css = {};
        css[this.modernizrCssPrefix("transform")] = transformString;
        return css;
    },

    modernizrCssPrefix : function (attr) {
        
        var str = Modernizr.prefixed(attr);
        return str.replace(/([A-Z])/g, function(str, m1){ 
            return '-' + m1.toLowerCase(); 
        }).replace(/^ms-/,'-ms-');
    },
});
    EpubFixed.FixedLayoutStyle = Backbone.Model.extend({

    initialize : function () {},

    getSinglePageSpreadCSS : function () {

        return {
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%",
            "-webkit-transform-origin" : "top left",
            "-moz-transform-origin" : "top left",
            "-o-transform-origin" : "top left",
            "-ms-transform-origin" : "top left",
            "left" : "0%" // Expects that the parent element is resized to wrap it perfectly; this is done with
            //   javascript in the fixed pagination view
        };
    },

    getSvgSinglePageSpreadCSS : function () {

        return {
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%",
            "left" : "25%" // Expects that the parent element is resized to wrap it perfectly; this is done with
            //   javascript in the fixed pagination view
        };
    },

    getPageSpreadLeftCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "right" : "50%",
            "left" : "", // Have to clear the left if it was set for this page on a single page spread
            "-webkit-transform-origin" : "top right",
            "-moz-transform-origin" : "top right",
            "-o-transform-origin" : "top right",
            "-ms-transform-origin" : "top right",
            "background-color" : "#FFF"
        };
    },

    getSvgPageSpreadLeftCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "right" : "50%",
            "left" : "", // Have to clear the left if it was set for this page on a single page spread
            "background-color" : "#FFF"
        };
    },

    getPageSpreadRightCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "left" : "50%",
            "-webkit-transform-origin" : "top left",
            "-moz-transform-origin" : "top left",
            "-o-transform-origin" : "top left",
            "-ms-transform-origin" : "top left",
            "background-color" : "#FFF" 
        };
    },

    getSvgPageSpreadRightCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "left" : "50%",
            "background-color" : "#FFF" 
        };
    },

    getPageSpreadCenterCSS : function () {

        return {
            "position" : "absolute",
            "overflow" : "hidden", 
            "height" : "100%",
            "width" : "100%",
            "left" : "25%",
            "-webkit-transform-origin" : "top left",
            "-moz-transform-origin" : "top left",
            "-o-transform-origin" : "top left",
            "-ms-transform-origin" : "top left",
            "z-index" : "11",
            "background-color" : "#FFF" 
        };
    },

    getSvgPageSpreadCenterCSS : function () {

        return {
            "position" : "absolute",
            "overflow" : "hidden", 
            "height" : "100%",
            "width" : "100%",
            "left" : "25%",
            "z-index" : "11",
            "background-color" : "#FFF" 
        };
    }
});
    EpubFixed.FixedPageView = Backbone.View.extend({

    el : "<div class='fixed-page-wrapper'> \
            <iframe scrolling='no' \
                    frameborder='0' \
                    marginwidth='0' \
                    marginheight='0' \
                    style='height:100%;width:100%;' \
                    class='fixed-content'> \
            </iframe> \
          </div>",

    initialize : function (options) {

        this.sizing;
        this.styles = new EpubFixed.FixedLayoutStyle();
        this.pageSpread = options.pageSpread;
        this.iframeSrc = options.iframeSrc;
        this.fixedLayoutType = options.fixedLayoutType;

        // REFACTORING CANDIDATE: See if this can be done in the render method
        if (options.viewerSettings.syntheticLayout) {
            this.setSyntheticPageSpreadStyle();       
        }
        else {
            this.setSinglePageSpreadStyle();
        }
    },

    // REFACTORING CANDIDATE: Use page set event context to trigger the content document loaded event
    render : function (goToLast, elementIdToShow, linkClickHandler, handlerContext, isSynthetic) {

        var that = this;
        this.get$iframe().attr("src", this.iframeSrc);
        this.get$iframe().on("load", function () {

            // "Forward" the epubReadingSystem object to the iframe's own window context.
            // Note: the epubReadingSystem object may not be ready when directly using the
            // window.onload callback function (from within an (X)HTML5 EPUB3 content document's Javascript code)
            // To address this issue, the recommended code is:
            // -----
            // function doSomething() { console.log(navigator.epubReadingSystem); };
            // 
            // // With jQuery:
            // $(document).ready(function () { setTimeout(doSomething, 200); });
            // 
            // // With the window "load" event:
            // window.addEventListener("load", function () { setTimeout(doSomething, 200); }, false);
            // 
            // // With the modern document "DOMContentLoaded" event:
            // document.addEventListener("DOMContentLoaded", function(e) { setTimeout(doSomething, 200); }, false);
            // -----
            if (typeof navigator.epubReadingSystem != 'undefined')
            {
               var iFrame = that.get$iframe()[0];
               var iFrameWindow = iFrame.contentWindow || iFrame.contentDocument.parentWindow;
               var ers = navigator.epubReadingSystem; //iFrameWindow.parent.navigator.epubReadingSystem
               iFrameWindow.navigator.epubReadingSystem = ers;
            }

            that.sizing = new EpubFixed.FixedSizing({ contentDocument : that.get$iframe()[0].contentDocument });
            that.injectLinkHandler(that.get$iframe(), linkClickHandler, handlerContext);
            // that.applyKeydownHandler($(view.iframe()));
            if (that.fixedLayoutType !== "svg") {
                that.setPageSize(isSynthetic);
            }
            that.trigger("contentDocumentLoaded");
        });
        
        return this.el;
    },

    get$iframe : function () {
        return $("iframe", this.$el);
    },

    hidePage : function () {
        this.$el.hide();
    },

    showPage : function () {
        this.$el.show();
    },

    getTransformedWidth : function () {
        return this.sizing.transformedPageSize.width;
    },

    getTransformedHeight : function () {
        return this.sizing.transformedPageSize.height;
    },

    setSinglePageSpreadStyle : function () {

        var singlePageCss;
        if (this.fixedLayoutType === "svg") {
            singlePageCss = this.styles.getSvgSinglePageSpreadCSS();
            this.$el.css(singlePageCss);
        }
        else {
            singlePageCss = this.styles.getSinglePageSpreadCSS();
            this.$el.css(singlePageCss);
            this.setPageSize(false);
        }
    },

    setSyntheticPageSpreadStyle : function () {

        var pageSpread = this.pageSpread;
        var syntheticPageCss;

        if (this.fixedLayoutType === "svg") {
            if (pageSpread === "left") {
                syntheticPageCss = this.styles.getSvgPageSpreadLeftCSS();
            }
            else if (pageSpread === "right") {
                syntheticPageCss = this.styles.getSvgPageSpreadRightCSS();
            }
            else if (pageSpread === "center") {
                syntheticPageCss = this.styles.getSvgPageSpreadCenterCSS();
            }
            this.$el.css(syntheticPageCss);
        }
        else {
            if (pageSpread === "left") {
                syntheticPageCss = this.styles.getPageSpreadLeftCSS();
            }
            else if (pageSpread === "right") {
                syntheticPageCss = this.styles.getPageSpreadRightCSS();
            }
            else if (pageSpread === "center") {
                syntheticPageCss = this.styles.getPageSpreadCenterCSS();
            }
            this.$el.css(syntheticPageCss);
            this.setPageSize(true);
        }
    },

    setPageSize : function (isSynthetic) {

        var $readerElement = this.$el.parent().parent();
        if (this.sizing !== undefined) {

            var transformCss;
            this.sizing.updateMetaSize();
            transformCss = this.sizing.fitToScreen($readerElement.width(), $readerElement.height(), isSynthetic);
            this.$el.css(transformCss);
        }
    },

    injectLinkHandler : function ($iframe, linkClickHandler, handlerContext) {

        var that = this;
        $('a', $iframe).on("click", function (e) {
            linkClickHandler.call(handlerContext, e);
        });
    }
});
    EpubFixed.ImagePageView = Backbone.View.extend({

    el : "<div class='fixed-page-wrapper' style='height:100%;'> \
            <img src='#'' alt=''/> \
          </div>",

    initialize : function (options) {

        this.sizing;
        this.styles = new EpubFixed.FixedLayoutStyle();
        this.pageSpread = options.pageSpread;
        this.imageSrc = options.imageSrc;
        if (options.viewerSettings.syntheticLayout) {
            this.setSyntheticPageSpreadStyle();       
        }
        else {
            this.setSinglePageSpreadStyle();
        }
    },

    // REFACTORING CANDIDATE: Use page set event context to trigger the contentDocumentLoaded event
    render : function (goToLast, elementIdToShow, linkClickHandler, handlerContext, isSynthetic) {

        var that = this;
        $("img", this.$el).attr("src", this.imageSrc);
        this.$("img").on("load", function() { 

            that.sizing = new EpubFixed.FixedSizing({ contentDocument : $("img", that.el)[0] });
            // that.applyKeydownHandler($(view.iframe()));
            // that.mediaOverlayController.pagesLoaded();
            that.setPageSize(isSynthetic);
            that.trigger("contentDocumentLoaded");
        });

        return this.el;
    },

    hidePage : function () {
        this.$el.hide();
    },

    showPage : function () {
        this.$el.show();
    },

    getTransformedWidth : function () {
        return this.sizing.transformedPageSize.width;
    },

    getTransformedHeight : function () {
        return this.sizing.transformedPageSize.height;
    },

    setSinglePageSpreadStyle : function () {

        var transformCss;
        this.$el.css(this.styles.getSinglePageSpreadCSS());
        this.setPageSize(false);
    },

    setSyntheticPageSpreadStyle : function () {

        var pageSpread = this.pageSpread;
        var transformCss;
        if (pageSpread === "left") {
            this.$el.css(this.styles.getPageSpreadLeftCSS());
        }
        else if (pageSpread === "right") {
            this.$el.css(this.styles.getPageSpreadRightCSS());
        }
        else if (pageSpread === "center") {
            this.$el.css(this.styles.getPageSpreadCenterCSS());
        }
        this.setPageSize(true);
    },

    setPageSize : function (isSynthetic) {

        var $readerElement = this.$el.parent().parent();
        if (this.sizing !== undefined) {

            var transformCss;
            this.sizing.updateMetaSize();
            transformCss = this.sizing.fitToScreen($readerElement.width(), $readerElement.height(), isSynthetic);
            this.$el.css(transformCss);
        }
    }
});
    EpubFixed.FixedPaginationView = Backbone.View.extend({

	el : "<div class='fixed-pages-view' style='position:relative; height:100%'> \
            <div class='fixed-spine-divider' style='position:absolute;z-index:2;width:1px;left:50%;top:3%;height:93%;'></div> \
          </div>",

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize : function (options) {

		var that = this;
		this.fixedPageViews = new EpubFixed.FixedPageViews({ spineObjects : options.spineObjects });
		this.viewerSettings = options.viewerSettings;

		// Rationale: Propagate the loaded event after all the content documents are loaded
        this.fixedPageViews.on("epubLoaded", function () {
            that.trigger("contentDocumentLoaded");
            that.createEpubBorder();
            that.$el.css("opacity", "1");
        }, this);

        this.customizer = new EpubFixed.FixedCustomizer();

		// this.mediaOverlayController = this.model.get("media_overlay_controller");
        // this.mediaOverlayController.setPages(this.pages);
        // this.mediaOverlayController.setView(this);

        // this.mediaOverlayController.on("change:mo_text_id", this.highlightText, this);
        // this.mediaOverlayController.on("change:active_mo", this.indicateMoIsPlaying, this);
	},

	render : function (goToLastPage, hashFragmentId) {

		this.fixedPageViews.renderFixedPages(this.$el[0], this.viewerSettings, this.linkClickHandler, this);
		return this.el;
	},

    // REFACTORING CANDIDATE: 
    //   At the moment, the page-turn events are triggered from the delegate, as well as 
    //   checking of page boundry conditions. Not sure if this makes sense, or if it would be clearer
    //   if that stuff was in these two methods instead. 
	nextPage : function () {

		this.fixedPageViews.nextPage(this.viewerSettings.syntheticLayout, this);
	},

	previousPage : function () {

		this.fixedPageViews.previousPage(this.viewerSettings.syntheticLayout, this);
	},

    setSyntheticLayout : function (isSynthetic) {

        if (isSynthetic && this.viewerSettings.syntheticLayout === false) {
            this.viewerSettings.syntheticLayout = true;
            this.fixedPageViews.setSyntheticLayout(true);
            $(".fixed-spine-divider", this.$el).show();
            this.createEpubBorder();
            this.trigger("layoutChanged", true);
        }
        else if (!isSynthetic && this.viewerSettings.syntheticLayout === true) {
            this.viewerSettings.syntheticLayout = false;
            this.fixedPageViews.setSyntheticLayout(false);
            $(".fixed-spine-divider", this.$el).hide();
            this.createEpubBorder();
            this.trigger("layoutChanged", false);
        }
    },

    showPageNumber : function (pageNumber) {

        var startPageNumbers = this.fixedPageViews.get("currentPages");
        this.fixedPageViews.showPageNumber(pageNumber, this.viewerSettings.syntheticLayout);

        if (startPageNumbers != this.fixedPageViews.get("currentPages")) {
            this.trigger("displayedContentChanged");    
        }
    },

    showPagesView : function () {

        var currentPageNumber = this.fixedPageViews.get("currentPages")[0];
        this.$el.show();
        this.fixedPageViews.showPageNumber(currentPageNumber, this.viewerSettings.syntheticLayout);
    },

    hidePagesView : function () {

        this.$el.hide();
        this.fixedPageViews.hidePageViews();
    },

    resizePageViews : function () {

        this.fixedPageViews.resizePageViews(this.viewerSettings.syntheticLayout);
        this.createEpubBorder();
        this.trigger("displayedContentChanged");
    },

    customize : function (customProperty, styleNameOrCSS) {

        // Font size, margin and theme are not included

        this.customizer.setCustomStyle(
            customProperty, 
            styleNameOrCSS, 
            this.fixedPageViews.get("fixedPages"),
            this.el,
            $(".fixed-spine-divider", this.$el)[0],
            this.viewerSettings.syntheticLayout
        );
    },
    
 //    // override
	// indicateMoIsPlaying: function () {
	// 	var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderFixedMoPlaying(
	// 		this.pages.get("current_page"),
	// 		this.mediaOverlayController.get("active_mo"),
	// 		this
 //        );
	// },
    
 //    // override
	// highlightText: function () {
	// 	var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderFixedLayoutMoFragHighlight(
	// 		this.pages.get("current_page"),
	// 		this.mediaOverlayController.get("mo_text_id"),
	// 		this
 //        );
	// },
    
 //    // override
 //    // Description: return the set of all elements for this spine item that have an @id attribute.
 //    // Used by MO.
 //    getAllPageElementsWithId: function() {
 //        return $('body').find("[id]");
 //    },
    
    
	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	destruct : function () {

        this.off("epubLoaded");
        // this.mediaOverlayController.off("change:mo_text_id", this.highlightText);
        // this.mediaOverlayController.off("change:active_mo", this.indicateMoIsPlaying);
	},

    linkClickHandler : function (e) {

        this.trigger("epubLinkClicked", e);
    },

    // Rationale: Wraps a border around the absolutely position pages on the screen. This is used for both layout (in the case
    //   of a single page spread, and for having a border around the pages that can be styled. 
    createEpubBorder : function () {

        var currentPages = this.fixedPageViews.get("currentPages");
        var currPageViewInfo;
        var epubBorderSize;
        var originalWidth;
        var originalHeight;

        if (this.viewerSettings.syntheticLayout) {
            epubBorderSize = this.getSyntheticBorderSize();   
        }
        else {
            epubBorderSize = this.getSinglePageBorderSize();
        }

        originalWidth = this.$el.outerWidth(true);
        originalHeight = this.$el.outerHeight(true);

        if (epubBorderSize.width < originalWidth) {
            this.setHorizontalMarginsForBorder(epubBorderSize.width, originalWidth);
        }
        else if (epubBorderSize.height < originalHeight) {
            this.setVerticalMarginsForBorder(epubBorderSize.height, originalHeight);
        }
    },

    setHorizontalMarginsForBorder : function (epubBorderWidth, currentWidth) {

        var HEURISTIC_ADJUSTMENT = 5;
        var difference = currentWidth - epubBorderWidth;
        var margin = Math.ceil(difference / 2) - HEURISTIC_ADJUSTMENT;
        this.$el.css({ "margin-left" : margin , "margin-right" : margin });
    },

    setVerticalMarginsForBorder : function (epubBorderHeight, currentHeight) {

        var HEURISTIC_ADJUSTMENT = 5;
        var difference = currentHeight - epubBorderHeight;
        var margin = Math.ceil(difference / 2) - HEURISTIC_ADJUSTMENT;
        this.$el.css({ "margin-top" : margin , "margin-bottom" : margin });
    },

    getSinglePageBorderSize : function () {

        var page;
        var currentPageNumber = this.fixedPageViews.get("currentPages")[0];

        currentPage = this.fixedPageViews.getPageViewInfo(currentPageNumber).fixedPageView;

        return {
            height : currentPage.getTransformedHeight(),
            width : currentPage.getTransformedWidth(),
        };
    },

    getSyntheticBorderSize : function () {

        var firstPage; 
        var secondPage;
        var maxHeight;
        var maxWidth;
        var firstPageNumber = this.fixedPageViews.get("currentPages")[0];
        var secondPageNumber = this.fixedPageViews.get("currentPages")[1];
        var NUMBER_OF_PAGES_SHOWN = 2;

        firstPage = this.fixedPageViews.getPageViewInfo(firstPageNumber).fixedPageView;

        // Rationale: Might only be showing one page in synthetic mode
        if (secondPageNumber !== undefined) { 
            secondPage = this.fixedPageViews.getPageViewInfo(secondPageNumber).fixedPageView;

            maxHeight = Math.max(firstPage.getTransformedHeight(), secondPage.getTransformedHeight());
            maxWidth = Math.max(firstPage.getTransformedWidth(), secondPage.getTransformedWidth()) * NUMBER_OF_PAGES_SHOWN;
        }
        else {
            maxHeight = firstPage.getTransformedHeight();
            maxWidth = firstPage.getTransformedWidth() * NUMBER_OF_PAGES_SHOWN;
        }
        
        return {
            height : maxHeight,
            width : maxWidth,
        };
    }

	// setFontSize: function() {
	// 	var size = this.model.get("font_size") / 10;
	// 	$('#readium-content-container').css("font-size", size + "em");
	// 	this.showCurrentPages();
	// },

	// applyKeydownHandler : function ($pageViewContainer) {

	// 	var that = this;
	// 	$pageViewContainer.contents().keydown(function (e) {

	// 		if (e.which == 39) {
	// 			that.pages.goRight(); // Have to get ppd and two up
	// 		}
							
	// 		if (e.which == 37) {
	// 			that.pages.goLeft(); // Have to get ppd and two up
	// 		}
	// 	});
	// }
});
    EpubFixed.FixedCustomizer = Backbone.Model.extend({

    initialize : function (attributes, options) {

        // The list of page views
        this.set("customPageBorder", new EpubFixed.FixedCustomPageBorder());
        this.set("customEpubBorder", new EpubFixed.FixedCustomEpubBorder());  
        this.set("customSpineDivider", new EpubFixed.FixedCustomSpineDivider());
    },

    // ----- PUBLIC INTERFACE -------------------------------------------------------------------

    setCustomStyle : function (customProperty, styleNameOrCSS, pageViews, epubBorderElement, spineElement, isSynthetic) {

        var that = this;
        if (customProperty === "fixed-epub-border" || customProperty === "epub-border") {
            that.get("customEpubBorder").setCurrentStyle(styleNameOrCSS, epubBorderElement);
        }
        else if (customProperty === "fixed-spine-divider" || customProperty === "spine-divider") {
            this.get("customSpineDivider").setCurrentStyle(styleNameOrCSS, spineElement);
        }
        else if (customProperty === "fixed-page-border" || customProperty === "page-border") {
            that.get("customPageBorder").setCurrentStyle(styleNameOrCSS, pageViews);
        }
        else if (customProperty === "fixed-page-border-left") {
            that.get("customPageBorder").setCurrentStyle(styleNameOrCSS, pageViews, "left");
        }
        else if (customProperty === "fixed-page-border-right") {
            that.get("customPageBorder").setCurrentStyle(styleNameOrCSS, pageViews, "right");
        }
    }

    // ----- PRIVATE HELPERS -------------------------------------------------------------------

    // 

});
    EpubFixed.FixedCustomPageBorder = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.lastSetStyle = {};
    },

    setCurrentStyle : function (styleNameOrCSSObject, pageViews, pageSpread) {

        var that = this;
        var borderStyle;

        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            // Iterate through each page view and set it's style
            _.each(pageViews, function (pageViewInfo) {

                if (pageSpread && pageViewInfo.pageSpread !== pageSpread) {
                    return;
                }

                var $element = pageViewInfo.fixedPageView.$el;
                if (pageSpread === "left") {
                    borderStyle = that.getPageSpreadDefaultBorderStyle(styleNameOrCSSObject, "left");
                }
                else if (pageSpread === "right") {
                    borderStyle = that.getPageSpreadDefaultBorderStyle(styleNameOrCSSObject, "right");
                }
                else {
                    borderStyle = that.getDefaultBorderStyle(styleNameOrCSSObject);
                }
                
                borderStyle = that.keepRequiredCSS(borderStyle);

                if (borderStyle !== undefined) {
                    that.removeLastSetStyle($element);
                    that.renderCurrentStyle($element, borderStyle);
                }
            }); 
            this.setAllCurrentStyles(borderStyle);
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            borderStyle = that.keepRequiredCSS(styleNameOrCSSObject);
            _.each(pageViews, function (pageViewInfo) {
                that.removeLastSetStyle($element);
                that.renderCurrentStyle($element, borderStyle);
            });
            this.setAllCurrentStyles(borderStyle);
        }
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function ($element, currentStyle) {

        $element.css(currentStyle);
    },

    getPageSpreadDefaultBorderStyle : function (defaultName, pageSpread) {

        var defaultCSS;
        if (defaultName === "box-shadow") {

            if (pageSpread === "left") {
                return { "box-shadow" : "0px 0px 5px 5px rgba(80, 80, 80, 0.5)" };
            }
            else if (pageSpread === "right") {
                return { "box-shadow" : "0px 0px 5px 5px rgba(80, 80, 80, 0.5)" };
            }
            else {
                return undefined;
            }
        }
        else if (defaultName == "none") {
            return {};
        }
        else {
            return undefined;
        }
    },

    getDefaultBorderStyle : function (defaultName) {

        var defaultCSS;
        if (defaultName === "box-shadow") {
            return { "box-shadow" : "0 0 5px 5px rgba(80, 80, 80, 0.5)" };
        }
        else if (defaultName == "none") {
            return {};
        }
        else {
            return undefined;
        }
    },

    setAllCurrentStyles : function (styles) {
        this.lastSetStyle = _.extend(this.lastSetStyle, styles);
    },

    keepRequiredCSS : function (customCSS) {

        var requiredCSS = [
            "position",
            "z-index",
            "top",
            "left",
            "width",
            "height"
        ];

        // Remove properties that can't be changed
        _.each(requiredCSS, function (propertyName) {
            if (!customCSS.hasOwnProperty(propertyName)) {
                delete customCSS[propertyName];
            }
        });

        // Rationale: The underscore.js extend method will combine two (or more) objects. However, any properties in the second
        //   object will overwrite the same properties in the first object. This is desired, as the position properties must be 
        //   specified as defined in this view. 
        return customCSS;
    },

    // REFACTORING CANDIDATE: Get modernizr in here
    removeLastSetStyle : function ($element) {

        _.each(this.lastSetStyle, function (styleValue, style) {
            $element.css(style, "");
        });
    }
});
    EpubFixed.FixedCustomEpubBorder = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.lastSetStyle = {};
    },

    setCurrentStyle : function (styleNameOrCSSObject, epubBorderElement) {

        var that = this;
        var borderStyle;
        var $element = $(epubBorderElement);

        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            borderStyle = that.getDefaultBorderStyle(styleNameOrCSSObject);
            borderStyle = that.keepRequiredCSS(borderStyle);

            if (borderStyle !== undefined) {
                that.removeLastSetStyle($element);
                that.renderCurrentStyle($element, borderStyle);
            }
            this.setAllCurrentStyles(borderStyle);
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            borderStyle = that.keepRequiredCSS(styleNameOrCSSObject);
            that.removeLastSetStyle($element);
            that.renderCurrentStyle($element, borderStyle);
            this.setAllCurrentStyles(borderStyle);
        }
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function ($element, currentStyle) {

        $element.css(currentStyle);
    },

    getDefaultBorderStyle : function (defaultName) {

        var defaultCSS;
        if (defaultName === "box-shadow") {
            return { "box-shadow" : "0 0 5px 5px rgba(80, 80, 80, 0.5)" };
        }
        else if (defaultName == "none") {
            return {};
        }
        else {
            return undefined;
        }
    },

    setAllCurrentStyles : function (styles) {
        this.lastSetStyle = _.extend(this.lastSetStyle, styles);
    },

    keepRequiredCSS : function (customCSS) {

        var requiredCSS = [
            "position",
            "z-index",
            "top",
            "left",
            "width",
            "height"
        ];

        // Remove properties that can't be changed
        _.each(requiredCSS, function (propertyName) {
            if (!customCSS.hasOwnProperty(propertyName)) {
                delete customCSS[propertyName];
            }
        });

        // Rationale: The underscore.js extend method will combine two (or more) objects. However, any properties in the second
        //   object will overwrite the same properties in the first object. This is desired, as the position properties must be 
        //   specified as defined in this view. 
        return customCSS;
    },

    // REFACTORING CANDIDATE: Get modernizr in here
    removeLastSetStyle : function ($element) {

        _.each(this.lastSetStyle, function (styleValue, style) {
            $element.css(style, "");
        });
    }
});
    EpubFixed.FixedCustomSpineDivider = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.lastSetStyle = {};
    },

    setCurrentStyle : function (styleNameOrCSSObject, spineElement) {

        var that = this;
        var spineStyle;
        var $element = $(spineElement);

        // Rationale: If it's a string, we assume that the user specified one of the default names
        if (typeof styleNameOrCSSObject === "string") {

            spineStyle = that.getDefaultSpineStyle(styleNameOrCSSObject);
            spineStyle = that.keepRequiredCSS(spineStyle);

            if (spineStyle !== undefined) {
                that.removeLastSetStyle($element);
                that.renderCurrentStyle($element, spineStyle);
            }
            this.setAllCurrentStyles(spineStyle);
        }
        // Rationale: At this point, we're just assuming that the CSS provided is correct. Validation of some sort might be desirable 
        //   at some point; hard to say. 
        else if (typeof styleNameOrCSSObject === "object") {

            spineStyle = that.keepRequiredCSS(styleNameOrCSSObject);
            that.removeLastSetStyle($element);
            that.renderCurrentStyle($element, spineStyle);
            this.setAllCurrentStyles(spineStyle);
        }
    },

    // ------ PRIVATE HELPERS --------------------------------------------------------------

    renderCurrentStyle : function ($element, currentStyle) {

        $element.css(currentStyle);
    },

    getDefaultSpineStyle : function (defaultName) {

        var defaultCSS;
        if (defaultName === "box-shadow") {
            return { "box-shadow" : "0 0 5px 5px rgba(80, 80, 80, 0.5)" };
        }
        else if (defaultName == "none") {
            return {};
        }
        else {
            return undefined;
        }
    },

    setAllCurrentStyles : function (styles) {
        this.lastSetStyle = _.extend(this.lastSetStyle, styles);
    },

    keepRequiredCSS : function (customCSS) {

        var requiredCSS = [
            "position",
            "z-index",
            "top",
            "left",
            "width",
            "height"
        ];

        // Remove properties that can't be changed
        _.each(requiredCSS, function (propertyName) {
            if (!customCSS.hasOwnProperty(propertyName)) {
                delete customCSS[propertyName];
            }
        });

        // Rationale: The underscore.js extend method will combine two (or more) objects. However, any properties in the second
        //   object will overwrite the same properties in the first object. This is desired, as the position properties must be 
        //   specified as defined in this view. 
        return customCSS;
    },

    // REFACTORING CANDIDATE: Get modernizr in here
    removeLastSetStyle : function ($element) {

        _.each(this.lastSetStyle, function (styleValue, style) {
            $element.css(style, "");
        });
    }
});

    var fixedView = new EpubFixed.FixedPaginationView({
        spineObjects : spineObjects,
        viewerSettings : viewerSettingsObject
    });

    // Description: The public interface
    return {

        render : function (goToLastPage, hashFragmentId) {
            return fixedView.render(goToLastPage, hashFragmentId);
        },
        nextPage : function () {
            return fixedView.nextPage();
        },
        previousPage : function () {
            return fixedView.previousPage();
        },
        showPageByHashFragment : function (hashFragmentId) {
            return;
        },
        showPageByNumber : function (pageNumber) {
            return fixedView.showPageNumber(pageNumber);
        },
        showPageByCFI : function (CFI) {
            return;
        },
        numberOfPages : function () {
            return fixedView.fixedPageViews.get("fixedPages").length;
        },
        currentPage : function () {
            return fixedView.fixedPageViews.get("currentPages");
        },
        onFirstPage : function () {
            return fixedView.fixedPageViews.onFirstPage();
        },
        onLastPage : function () {
            return fixedView.fixedPageViews.onLastPage();
        },
        showPagesView : function () {
            return fixedView.showPagesView();
        },
        hidePagesView : function () {
            return fixedView.hidePagesView();
        },
        setSyntheticLayout : function (isSynthetic) {
            return fixedView.setSyntheticLayout(isSynthetic);
        },
        on : function (eventName, callback, callbackContext) {
            return fixedView.on(eventName, callback, callbackContext);
        },
        off : function (eventName, callback) {
            return fixedView.off(eventName, callback);
        },
        resizeContent : function () {
            return fixedView.resizePageViews();
        },
        customize : function (customProperty, styleNameOrCSS) {
            fixedView.customize(customProperty, styleNameOrCSS);
            return this;
        }
    };
};

    var EpubParserModule = function(packageDocumentURI, packageDocumentXML) {

    var EpubParser = {};
    // `PackageDocumentParser` is used to parse the xml of an epub package
// document and build a javascript object. The constructor accepts an
// instance of `URI` that is used to resolve paths during the process
EpubParser.PackageDocumentParser = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.packageDocumentURI = new URI(this.get("packageDocumentURI"));
        var xml = this.get("packageDocumentXML");
        if (typeof(xml) === "string" ) {
            var parser = new window.DOMParser;
            xmlDom = parser.parseFromString(xml, 'text/xml');
            this.set({ xmlDom : xmlDom });
        }
        else {
            throw new Error("XML string representation of package document is required");
        }
    },

    // Parse an XML package document into a javascript object
    parse : function() {

        var json, manifest, cover, xmlDom;
        var xmlDom = this.get("xmlDom");

        json = {};
        json.metadata = this.getJsonMetadata(xmlDom);
        json.bindings = this.getJsonBindings(xmlDom);
        json.spine = this.getJsonSpine(xmlDom);
        json.manifest = this.getJsonManifest(xmlDom);

        // parse the page-progression-direction if it is present
        json.paginate_backwards = this.paginateBackwards(xmlDom);

        // try to find a cover image
        cover = this.getCoverHref(xmlDom);
        if (cover) {
            json.metadata.cover_href = cover;
        }       
        if (json.metadata.layout === "pre-paginated") {
            json.metadata.fixed_layout = true;
        }
        
        // THIS SHOULD BE LEFT IN (BUT COMMENTED OUT), AS MO SUPPORT IS TEMPORARILY DISABLED
        // create a map of all the media overlay objects
        // json.mo_map = this.resolveMediaOverlays(json.manifest);

        // parse the spine into a proper collection
        json.spine = this.parseSpineProperties(json.spine);

        // return the parse result
        return json;
    },

    getJsonSpine : function () {

        var $spineElements;
        var jsonSpine = [];
        var xmlDom = this.get("xmlDom");

        $spineElements = $("spine", xmlDom).children();
        $.each($spineElements, function (spineElementIndex, currSpineElement) {

            var $currSpineElement = $(currSpineElement);
            var spineItem = {

                idref : $currSpineElement.attr("idref") ? $currSpineElement.attr("idref") : "",
                linear : $currSpineElement.attr("linear") ? $currSpineElement.attr("linear") : "",
                properties : $currSpineElement.attr("properties") ? $currSpineElement.attr("properties") : ""
            };

            jsonSpine.push(spineItem);
        });

        return jsonSpine;
    },

    getJsonMetadata : function () {

        var xmlDom = this.get("xmlDom");
        var $metadata = $("metadata", xmlDom);
        var namespace = "dc";
        var jsonMetadata = {};

        jsonMetadata.active_class = $("meta[property='media:active-class']", $metadata).text();
        jsonMetadata.author = this.getNamespacedTagContent("creator", namespace, $metadata);
        jsonMetadata.description = this.getNamespacedTagContent("description", namespace, $metadata);
        jsonMetadata.epub_version = $("package", xmlDom).attr("version") ? $("package", xmlDom).attr("version") : "";
        jsonMetadata.id = this.getNamespacedTagContent("identifier", namespace, $metadata);
        jsonMetadata.language = this.getNamespacedTagContent("language", namespace, $metadata);;
        jsonMetadata.layout = $("meta[property='rendition:layout']", $metadata).text();
        jsonMetadata.modified_date = $("meta[property='dcterms:modified']", $metadata).text();
        jsonMetadata.ncx = $("spine", xmlDom).attr("toc") ? $("spine", xmlDom).attr("toc") : "";
        jsonMetadata.orientation = $("meta[property='rendition:orientation']", $metadata).text();
        jsonMetadata.page_prog_dir = $("spine", xmlDom).attr("page-progression-direction") ? $("spine", xmlDom).attr("page-progression-direction") : "";
        jsonMetadata.pubdate = this.getNamespacedTagContent("date", namespace, $metadata);
        jsonMetadata.publisher = this.getNamespacedTagContent("publisher", namespace, $metadata)
        jsonMetadata.rights = this.getNamespacedTagContent("rights", namespace, $metadata);
        jsonMetadata.spread = $("meta[property='rendition:spread']", $metadata).text();
        jsonMetadata.title = this.getNamespacedTagContent("title", namespace, $metadata);

        return jsonMetadata;
    },

    getJsonManifest : function () {

        var that = this;
        var xmlDom = this.get("xmlDom");
        var $manifestItems = $("manifest", xmlDom).children(); 
        var jsonManifest = [];

        $.each($manifestItems, function (manifestElementIndex, currManifestElement) {

            var $currManifestElement = $(currManifestElement);
            var currManifestElementHref = $currManifestElement.attr("href") ? $currManifestElement.attr("href") : "";
            var manifestItem = {

                contentDocumentURI : that.resolveURI(currManifestElementHref),
                href : currManifestElementHref,
                id : $currManifestElement.attr("id") ? $currManifestElement.attr("id") : "", 
                media_overlay : $currManifestElement.attr("media-overlay") ? $currManifestElement.attr("media-overlay") : "",
                media_type : $currManifestElement.attr("media-type") ? $currManifestElement.attr("media-type") : "",
                properties : $currManifestElement.attr("properties") ? $currManifestElement.attr("properties") : ""
            };

            jsonManifest.push(manifestItem);
        });

        return jsonManifest;
    },

    getJsonBindings : function () {

        var xmlDom = this.get("xmlDom");
        var $bindings = $("bindings", xmlDom).children();
        var jsonBindings = [];

        $.each($bindings, function (bindingElementIndex, currBindingElement) {

            var $currBindingElement = $(currBindingElement);
            var binding = {

                handler : $currBindingElement.attr("handler") ? $currBindingElement.attr("handler") : "" ,
                media_type : $currBindingElement.attr("media-type") ? $currBindingElement.attr("media-type") : "" 
            };

            jsonBindings.push(binding);
        });

        return jsonBindings;
    },

    getCoverHref : function() {

        var dom = this.get("xmlDom");
        var manifest; var $imageNode;
        manifest = dom.getElementsByTagName('manifest')[0];

        // epub3 spec for a cover image is like this:
        /*<item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />*/
        $imageNode = $('item[properties~="cover-image"]', manifest);
        if($imageNode.length === 1 && $imageNode.attr("href") ) {
            return $imageNode.attr("href");
        }

        // some epub2's cover image is like this:
        /*<meta name="cover" content="cover-image-item-id" />*/
        var metaNode = $('meta[name="cover"]', dom);
        var contentAttr = metaNode.attr("content");
        if(metaNode.length === 1 && contentAttr) {
            $imageNode = $('item[id="'+contentAttr+'"]', manifest);
            if($imageNode.length === 1 && $imageNode.attr("href")) {
                return $imageNode.attr("href");
            }
        }

        // that didn't seem to work so, it think epub2 just uses item with id=cover
        $imageNode = $('#cover', manifest);
        if($imageNode.length === 1 && $imageNode.attr("href")) {
            return $imageNode.attr("href");
        }

        // seems like there isn't one, thats ok...
        return null;
    },

    parseSpineProperties : function(spine) {
        
        var parseProperiesString = function(str) {
            var properties = {};
            var allPropStrs = str.split(" "); // split it on white space
            for(var i = 0; i < allPropStrs.length; i++) {
                // brute force!!!
                //rendition:orientation landscape | portrait | auto
                //rendition:spread none | landscape | portrait | both | auto

                //rendition:page-spread-center 
                //page-spread | left | right
                //rendition:layout reflowable | pre-paginated
                if(allPropStrs[i] === "rendition:page-spread-center") properties.page_spread = "center";
                if(allPropStrs[i] === "page-spread-left") properties.page_spread = "left";
                if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
                if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
                if(allPropStrs[i] === "rendition:layout-reflowable") properties.fixed_flow = false;
                if(allPropStrs[i] === "rendition:layout-pre-paginated") properties.fixed_flow = true;
            }
            return properties;
            
        }

        for (var i = 0; i < spine.length; i++) {
            var props = parseProperiesString(spine[i].properties);
            // add all the properties to the spine item
            _.extend(spine[i], props);
        }
        return spine;
    },

    // resolve the url of smils on any manifest items that have a MO
    // attribute

    // NOTE: Removed media overlay support for the module refactoring

    // resolveMediaOverlays : function(manifest) {
    //     var that = this;
    //     var momap = {};
        
    //     // create a bunch of media overlay objects
    //     manifest.forEach( function(item) {
    //         if(item.get("media_type") === "application/smil+xml") {
    //             var url = that.resolveUri(item.get("href"));
    //             var moObject = new EpubParser.MediaOverlay();
    //             moObject.setUrl(url);
    //             moObject.fetch(); 
    //             momap[item.id] = moObject;
    //         }
    //     });
    //     return momap;
    // },

    // parse the EPUB3 `page-progression-direction` attribute
    paginateBackwards : function() {

        var xmlDom = this.get("xmlDom");
        return $('spine', xmlDom).attr('page-progression-direction') === "rtl";
    },

    resolveURI : function (epubResourceURI) {

        // Make absolute to the package document path
        var epubResourceRelURI = new URI(epubResourceURI);
        var epubResourceAbsURI = epubResourceRelURI.absoluteTo(this.packageDocumentURI);
        return epubResourceAbsURI.toString();
    },
    
    // ----- PRIVATE HELPERS -------------------------------------------------------------------
    
    // Description: Browser-insensitive method to retrieve text content of an xml tag in a namespace context (dc:title for example)
    // Arguments (
    //   tagName   (string) Tag name, without namespace information (title in the previous example)
    //   namespace (string) Namespace prefix (dc in the previous example)
    //   $context  (Object) jQuery object representing a set of xml elements to search in
    //  )
    //  Return (string) Content of the tag (empty string if not found)
    getNamespacedTagContent: function(tagName, namespace, $context) {
        var content = "";
        content = $(tagName, $context).text();//Webkit way
        if (!content)
        {
            content = $(namespace+"\\:"+tagName, $context).text();//Firefox way
        }
        
        return content;
    }
});

    var packageDocParser = new EpubParser.PackageDocumentParser({
        packageDocumentURI : packageDocumentURI,
        packageDocumentXML : packageDocumentXML
    });

    // Description: The public interface
    return {

        parse : function () {
            return packageDocParser.parse();
        }
    };
};

    var EpubModule = function(packageDocumentObject, packageDocumentXML) {

    var Epub = {};

    // Rationale: The order of these matters
    Epub.ManifestItem = Backbone.Model.extend({

	isSvg : function () {
		
		return this.get("media_type") === "image/svg+xml";
	},

	isImage : function () {
		
		var media_type = this.get("media_type");
		if (media_type && media_type.indexOf("image/") > -1) {
			// we want to treat svg as a special case, so they
			// are not images
			return media_type !== "image/svg+xml";
		}
		return false;
	}	
});
    Epub.Manifest = Backbone.Collection.extend({

    model : Epub.ManifestItem
});
    Epub.Metadata = Backbone.Model.extend({});
    // Description: This is a delegate that provides information about the appropriate page-spread property for fixed layout spine items
Epub.PageSpreadProperty = Backbone.Model.extend({

    initialize : function () {

        // "Constants" for page spread class
        this.CENTER_PAGE = "center_page";
        this.LEFT_PAGE = "left_page";
        this.RIGHT_PAGE = "right_page";
    },

    inferiBooksPageSpread : function (spineIndex, numSpineItems) {

        var pageNum = spineIndex + 1;

        // Rationale: For ibooks, odd pages go on the right. This means
        // the first page will always be on the right
        // without a left counterpart, so center it
        if (pageNum === 1) {
            
            return this.CENTER_PAGE;
        }
        // Rationale: If the last spine item in the book would be on the left, then
        //   it would have no left counterpart, so center it
        else if (pageNum % 2 === 0 && pageNum === numSpineItems) { 
            
            return this.CENTER_PAGE;
        }
        // Rationale: Otherwise first page goes on the right, and then alternate
        // left - right - left - right etc
        else {

            if (pageNum % 2 === 1) {
                return this.RIGHT_PAGE;
            }
            else {
                return this.LEFT_PAGE;
            }
        }
    },

    getPageSpreadFromProperties : function (pageSpreadProperty) {

        if (pageSpreadProperty === "left") {

            return this.LEFT_PAGE;
        }
        else if (pageSpreadProperty === "right") {

            return this.RIGHT_PAGE;
        }
        else if (pageSpreadProperty === "center") {

            return this.CENTER_PAGE;
        }
        else {

            return "";
        }
    },

    // NOTE: This method still cannot infer the page spread value when center pages are sporadically specified
    // REFACTORING CANDIDATE: Could still use some refactoring to enhance the clarity of the algorithm
    
    // Rationale: If the page spread property is not set, we must iterate back through the EPUB's spine items to find 
    //   the last spine item with a page-spread value set. We can use that value, whether there are an even or odd
    //   number of pages between this spine item and the "last" one, and the page progression direction of the EPUB
    //   to determine the appropriate page spread value for this spine item. 
    inferUnassignedPageSpread : function (spineIndex, spine, pageProgDirection) {

        var lastSpecifiedPageSpread;
        var numPagesBetween;

        if (spine.at(spineIndex).get("page_spread") === "left" ||
            spine.at(spineIndex).get("page_spread") === "right" ||
            spine.at(spineIndex).get("page_spread") === "center") {

            return this.getPageSpreadFromProperties(spine.at(spineIndex).get("page_spread"));
        }
        // If this is the first spine item, assign left or right based on page progression direction
        else if (spineIndex === 0) {

            return pageProgDirection === "rtl" ? this.RIGHT_PAGE : this.LEFT_PAGE;
        }
        else {

            // Find last spine item with page-spread value and use it to determine the appropriate value for 
            //   this spine item. This loop iterates, in reverse order, from the current spine index to the
            //   spine item that had a specified page spread specified. 
            for (var currSpineIndex = spineIndex - 1; currSpineIndex >= 0; currSpineIndex--) {

                // REFACTORING CANDIDATE: This would be clearer if the currSpineIndex === 0 case was 
                //   handled seperately. 
                if (currSpineIndex === 0 || spine.at(currSpineIndex).get("page_spread")) {

                    lastSpecifiedPageSpread = this.lastSpecifiedPageSpread(
                        spine.at(currSpineIndex).get("page_spread"), 
                        pageProgDirection
                        );
                    numPagesBetween = spineIndex - currSpineIndex;

                    // Even number of pages between current and last spine item
                    if (numPagesBetween % 2 === 0) {

                        return lastSpecifiedPageSpread === "left" ? this.LEFT_PAGE : 
                            lastSpecifiedPageSpread === "right" ? this.RIGHT_PAGE :
                            pageProgDirection === "rtl" ? this.LEFT_PAGE : this.RIGHT_PAGE;
                    }
                    // Odd number of pages between current and last spine item with a specified page-spread value
                    else {

                        return lastSpecifiedPageSpread === "left" ? this.RIGHT_PAGE :
                            lastSpecifiedPageSpread === "right" ? this.LEFT_PAGE :
                            pageProgDirection === "rtl" ? this.RIGHT_PAGE : this.LEFT_PAGE;
                    }
                }
            }
        }
    },

    lastSpecifiedPageSpread : function (pageSpreadValue, pageProgDirection) {

        // Handles the case where currSpineIndex === 0 and a page-spread value has not been specified
        if (pageSpreadValue && pageSpreadValue !== "") {
            return pageSpreadValue;
        }
        else {
            return pageProgDirection === "rtl" ? "right" : "left";
        }
    }
});
    Epub.SpineItem = Epub.ManifestItem.extend({

    defaults : {
        "pageSpreadClass" : ""
    },

    initialize : function () {

        // if (this.isFixedLayout()) {
        //     this.on("change:content", this.parseMetaTags, this);
        //     this.loadContent();
        // }
    },

    // REFACTORING CANDIDATE: The meta tags thing has to be worked out
    // toJSON : function () {

        // var json = {};
        // json.width = this.get("meta_width") || 0;
        // json.height = this.get("meta_height") || 0;
        // json.uri = this.resolveUri(this.get('href'));
        // json.page_class = this.getPageSpreadClass();
        // return json;
    // },

    // REFACTORING CANDIDATE: This needs to change

    isFixedLayout : function () {

        // if it an svg or image then it is fixed layout
        if (this.isSvg() || this.isImage()) {
            return true;
        }

        // if there is a fixed_flow property, then it takes precedence
        if (typeof this.get("fixed_flow") !== 'undefined') {
            return this.get("fixed_flow");
        }

        // nothing special about this spine item, fall back to the books settings
        return false;
    },

    // Description: Determines if the first page of the content document should be offset in a synthetic layout
    firstPageOffset : function () {

        // Get book properties
        var notFixedLayout = !this.isFixedLayout();
        var pageProgDirIsRTL = this.get("page_prog_dir") === "rtl" ? true : false;
        var pageSpreadLeft = this.get("page_spread") === "left" ? true : false;
        var pageSpreadRight = this.get("page_spread") === "right" ? true : false;

        // Default to no page spread specified if they are both set on the spine item
        if (pageSpreadRight && pageSpreadLeft) {
            pageSpreadRight = false;
            pageSpreadLeft = false;
        }

        if (notFixedLayout) {

            if (pageProgDirIsRTL) {

                if (pageSpreadLeft) {
                    return true;
                }
            }
            else {

                if (pageSpreadRight) {
                    return true;
                }
            }
        }

        return false;
    },

    // NOTE: Media overlays have been disabled for the time being, which is why these methods are commented out. 

    // hasMediaOverlay : function() {
    //     return !!this.get("media_overlay") && !!this.getMediaOverlay();
    // },
    
    // getMediaOverlay : function() {
    //     return this.collection.getMediaOverlay(this.get("media_overlay"));
    // }
});
    Epub.Spine = Backbone.Collection.extend({

    model: Epub.SpineItem,
});
    // Description: This model provides an interface for navigating an EPUB's package document
Epub.PackageDocument = Backbone.Model.extend({

    initialize : function (attributes, options) {

        var packageDocument = this.get("packageDocumentObject");
        this.manifest = new Epub.Manifest(packageDocument.manifest);
        this.spine = new Epub.Spine(packageDocument.spine);
        this.metadata = new Epub.Metadata(packageDocument.metadata);
        this.bindings = new Epub.Spine(packageDocument.bindings);
        this.pageSpreadProperty = new Epub.PageSpreadProperty();

        // If this book is fixed layout, assign the page spread class
        if (this.isFixedLayout()) {
            this.assignPageSpreadClass();
        }
    },

    getSpineInfo : function () {

        var that = this;
        var spineInfo = [];
        this.spine.each(function (spineItem) {
            spineInfo.push(that.generateSpineInfo(spineItem));
        });

        return {
            spine : spineInfo, 
            bindings : this.bindings.toJSON()
        };
    },

    isFixedLayout : function () {

        if (this.metadata.get("fixed_layout")) {
            return true; 
        }
        else {
            return false;
        }
    },

    getManifestItemById : function (id) {

        var foundManifestItem = this.manifest.find(
            function (manifestItem) { 
                if (manifestItem.get("id") === id) {
                    return manifestItem;
                }
            });

        if (foundManifestItem) {
            return foundManifestItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    getManifestItemByIdref : function (idref) {

        var foundManifestItem = this.getManifestItemById(idref);
        if (foundManifestItem) {
            return foundManifestItem;
        }
        else {
            return undefined;
        }
    },

    getSpineItemByIdref : function (idref) {

        var foundSpineItem = this.getSpineModelByIdref(idref);
        if (foundSpineItem) {
            return foundSpineItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    getSpineItem : function (spineIndex) {

        var spineItem = this.spine.at(spineIndex);
        if (spineItem) {
            return spineItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    spineLength : function () {
        return this.spine.length;
    },

    // Description: gets the next position in the spine for which the
    // spineItem does not have `linear='no'`. The start
    // param is the non-inclusive position to begin the search
    // from. If start is not supplied, the search will begin at
    // postion 0. If no linear position can be found, this 
    // function returns undefined
    getNextLinearSpinePosition : function (currSpineIndex) {

        var spine = this.spine;
        if (currSpineIndex === undefined || currSpineIndex < 0) {
            currSpineIndex = 0;

            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        while (currSpineIndex < this.spineLength() - 1) {
            currSpineIndex += 1;
            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        // No next linear spine position.
        return undefined; 
    },

    // Description: gets the previous position in the spine for which the
    // spineItem does not have `linear='no'`. The start
    // param is the non-inclusive position to begin the search
    // from. If start is not supplied, the search will begin at
    // the end of the spine. If no linear position can be found, 
    // this function returns undefined
    getPrevLinearSpinePosition : function(currSpineIndex) {

        var spine = this.spine;
        if (currSpineIndex === undefined || currSpineIndex > this.spineLength() - 1) {
            currSpineIndex = this.spineLength() - 1;

            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        while (currSpineIndex > 0) {
            currSpineIndex -= 1;
            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        // No previous linear spine position.
        return undefined;
    },

    hasNextSection: function(currSpineIndex) {

        if (currSpineIndex >= 0 &&
            currSpineIndex <= this.spineLength() - 1) {
            
            return this.getNextLinearSpinePosition(currSpineIndex) > -1;
        }
        else {
            return false;
        }
    },

    hasPrevSection: function(currSpineIndex) {

        if (currSpineIndex >= 0 &&
            currSpineIndex <= this.spineLength() - 1) {

            return this.getPrevLinearSpinePosition(currSpineIndex) > -1;    
        }
        else {
            return false;
        }
    },

    pageProgressionDirection : function () {

        if (this.metadata.get("page_prog_dir") === "rtl") {
            return "rtl";
        }
        else if (this.metadata.get("page_prog_dir") === "default") {
            return "default";
        }
        else {
            return "ltr";
        }
    },

    getSpineIndexByHref : function (manifestHref) {

        var spineItem = this.getSpineModelFromHref(manifestHref);
        return this.getSpineIndex(spineItem);
    },

    getBindingByHandler : function (handler) {

        var binding = this.bindings.find(
            function (binding) {

                if (binding.get("handler") === handler) {
                    return binding;
                }
            });

        if (binding) {
            return binding.toJSON();
        }
        else {
            return undefined;
        }
    },

    generateSpineInfo : function (spineItem) {

        var isFixedLayout = false;
        var fixedLayoutType = undefined;
        var manifestItem = this.getManifestModelByIdref(spineItem.get("idref"));
        var isLinear;
        var firstPageIsOffset;
        var pageSpread;

        // Get fixed layout properties
        if (spineItem.isFixedLayout() || this.isFixedLayout()) {
            isFixedLayout = true;
            
            if (manifestItem.isSvg()) {
                fixedLayoutType = "svg";
            }
            else if (manifestItem.isImage()) {
                fixedLayoutType = "image";
            }
            else {
                fixedLayoutType = "xhtml";
            }
        }

        // Set primary reading order attribute
        if (spineItem.get("linear").trim() === "no") {
            isLinear = false;
        }
        else {
            isLinear = true;
        }

        // Set first page is offset parameter
        pageSpread = spineItem.get("page_spread");
        if (!isFixedLayout) {
            if (this.pageProgressionDirection() === "ltr" && pageSpread === "right") {
                firstPageIsOffset = true;
            }
            else if (this.pageProgressionDirection() === "rtl" && pageSpread === "left") {
                firstPageIsOffset = true;
            }
            else {
                firstPageIsOffset = false;
            }
        }

        return {
            contentDocumentURI : this.getManifestItemByIdref(spineItem.get("idref")).contentDocumentURI,
            title : this.metadata.get("title"),
            firstPageIsOffset : firstPageIsOffset,
            pageProgressionDirection : this.pageProgressionDirection(),
            spineIndex : this.getSpineIndex(spineItem),
            pageSpread : pageSpread,
            isFixedLayout : isFixedLayout, 
            fixedLayoutType : fixedLayoutType,
            mediaType : manifestItem.get("media_type"),
            linear : isLinear
        };
    },

    getPackageDocumentDOM : function () {

        var parser = new window.DOMParser;
        var packageDocumentDom = parser.parseFromString(this.get("packageDocument"), "text/xml");
        return packageDocumentDom;
    },

    getToc : function () {

        var item = this.getTocItem();
        if (item) {
            var href = item.get("contentDocumentURI");
            return href;
        }
        return null;
    },

    // Description: This is a convenience method that will generate an html list structure from an ncx XML 
    //   document. 
    generateTocListDOM : function (ncxXML) {

        var that = this;
        var ncxDOM;
        var $ncxOrderedList;

        if (typeof ncxXML !== "string") {
            return undefined;
        }

        ncxDOM = (new DOMParser()).parseFromString(ncxXML,"text/xml");
        $ncxOrderedList = this.getNcxOrderedList($("navMap", ncxDOM));
        return $ncxOrderedList[0];
    },

    tocIsNcx : function () {

        var contentDocURI = this.getTocItem().get("contentDocumentURI");
        var fileExtension = contentDocURI.substr(contentDocURI.lastIndexOf('.') + 1);

        if (fileExtension.trim().toLowerCase() === "ncx") {
            return true;
        }
        else {
            return false;
        }
    },

    // ----------------------- PRIVATE HELPERS -------------------------------- //

    getNcxOrderedList : function ($navMapDOM) {

        var that = this;
        var $ol = $("<ol></ol>");
        $.each($navMapDOM.children("navPoint"), function (index, navPoint) {
            that.addNavPointElements($(navPoint), $ol);
        });
        return $ol;
    },

    // Description: Constructs an html representation of NCX navPoints, based on an object of navPoint information
    // Rationale: This is a recursive method, as NCX navPoint elements can nest 0 or more of themselves as children
    addNavPointElements : function ($navPointDOM, $ol) {

        var that = this;

        // Add the current navPoint element to the TOC html 
        var navText = $navPointDOM.children("navLabel").text().trim();
        var navHref = $navPointDOM.children("content").attr("src");
        var $navPointLi = $("<li class='nav-elem'><a href='" + navHref + "'>'" + navText + "'</a></li>");
        
        // Append nav point info
        $ol.append($navPointLi);

        // Append ordered list of nav points
        if ($navPointDOM.children("navPoint").length > 0 ) {

            var $newLi = $("<li></li>");
            var $newOl = $("<ol></ol>");
            $.each($navPointDOM.children("navPoint"), function (navIndex, navPoint) {
                $newOl.append(that.addNavPointElements($(navPoint), $newOl));
            });

            $newLi.append($newOl);
            $ol.append($newLi);
        }
    },

    // Refactoring candidate: This search will always iterate through entire manifest; this should be modified to 
    //   return when the manifest item is found.
    getSpineModelFromHref : function (manifestHref) {

        var that = this;
        var resourceURI = new URI(manifestHref);
        var resourceName = resourceURI.filename();
        var foundSpineModel; 

        this.manifest.each(function (manifestItem) {

            var manifestItemURI = new URI(manifestItem.get("href"));
            var manifestItemName = manifestItemURI.filename();

            // Rationale: Return a spine model based on the manifest item id, which is the idref of the spine item
            if (manifestItemName === resourceName) {
                foundSpineModel = that.getSpineModelByIdref(manifestItem.get("id"));
            }
        });

        return foundSpineModel;
    },

    getSpineModelByIdref : function (idref) {

        var foundSpineItem = this.spine.find(
            function (spineItem) { 
                if (spineItem.get("idref") === idref) {
                    return spineItem;
                }
            });

        return foundSpineItem;
    },

    getManifestModelByIdref : function (idref) {

        var foundManifestItem = this.manifest.find(
            function (manifestItem) { 
                if (manifestItem.get("id") === idref) {
                    return manifestItem;
                }
            });

        return foundManifestItem;
    },

    getSpineIndex : function (spineItem) {

        return this.spine.indexOf(spineItem);
    },

    // Description: When rendering fixed layout pages we need to determine whether the page
    //   should be on the left or the right in two up mode, options are:
    //     left_page:      render on the left side
    //     right_page:     render on the right side
    //     center_page:    always center the page horizontally
    //   This property must be assigned when the package document is initialized
    // NOTE: Look into how spine items with the linear="no" property affect this algorithm 
    assignPageSpreadClass : function () {

        var that = this;
        var pageSpreadClass;
        var numSpineItems;

        // If the epub is apple fixed layout
        if (this.metadata.get("apple_fixed")) {

            numSpineItems = this.spine.length;
            this.spine.each(function (spineItem, spineIndex) {

                pageSpreadClass = that.pageSpreadProperty.inferiBooksPageSpread(spineIndex, numSpineItems);
                spineItem.set({ pageSpreadClass : pageSpreadClass });
            });
        }
        else {
            // For each spine item
            this.spine.each(function (spineItem, spineIndex) {

                if (spineItem.get("page_spread")) {

                    pageSpreadClass = that.pageSpreadProperty.getPageSpreadFromProperties(spineItem.get("page_spread"));
                    spineItem.set({ pageSpreadClass : pageSpreadClass });
                }
                else {

                    pageSpreadClass = that.pageSpreadProperty.inferUnassignedPageSpread(spineIndex, that.spine, that.pageProgressionDirection());
                    spineItem.set({ pageSpreadClass : pageSpreadClass });
                }
            });
        }
    },

    getTocItem : function() {

        var manifest = this.manifest;
        var metadata = this.metadata;
        var spine_id = this.metadata.get("ncx");

        var item = manifest.find(function(item){

            if (item.get("properties").indexOf("nav") !== -1) {
                return true;
            }
            else {
                return false;
            }
        });

        if( item ) {
            return item;
        }

        if( spine_id && spine_id.length > 0 ) {
            return manifest.find(function(item) {
                return item.get("id") === spine_id;
            });
        }

        return null;
    }

    // NOTE: Media overlays are temporarily disabled
    // getMediaOverlayItem : function(idref) {
    //     // just look up the object in the mo_map
    //     var map = this.get("mo_map");
    //     return map && map[idref];
    // },
});


    var packageDoc = new Epub.PackageDocument({
        packageDocumentObject : packageDocumentObject,
        packageDocument : packageDocumentXML
    });

    // Description: The public interface
    return {

        getSpineInfo : function () {
            return packageDoc.getSpineInfo();
        },
        isFixedLayout : function () {
            return packageDoc.isFixedLayout();
        },
        getManifestItemById : function (id) {
            return packageDoc.getManifestItemById(id);
        },
        getManifestItemByIdref : function (idref) {
            return packageDoc.getManifestItemByIdref(idref);
        },
        getSpineItemByIdref : function (idref) {
            return packageDoc.getSpineItemByIdref(idref);
        },
        getSpineItemByIndex : function (spineIndex) {
            return packageDoc.getSpineItem(spineIndex);
        },
        spineLength : function () {
            return packageDoc.spineLength();
        },
        getNextLinearSpinePosition : function (currSpineIndex) {
            return packageDoc.getNextLinearSpinePosition(currSpineIndex);
        },
        getPrevLinearSpinePosition : function (currSpineIndex) {
            return packageDoc.getPrevLinearSpinePosition(currSpineIndex);
        },
        hasNextSection : function (currSpineIndex) {
            return packageDoc.hasNextSection(currSpineIndex);
        },
        hasPrevSection : function (currSpineIndex) {
            return packageDoc.hasPrevSection(currSpineIndex);
        },
        pageProgressionDirection : function () {
            return packageDoc.pageProgressionDirection();
        },
        getSpineIndexByHref : function (manifestHref) {
            return packageDoc.getSpineIndexByHref(manifestHref);
        },
        getPackageDocumentDOM : function () {
            return packageDoc.getPackageDocumentDOM();
        },
        getTocURL : function () {
            return packageDoc.getToc();
        },
        generateTocListDOM : function (ncxXML) {
            return packageDoc.generateTocListDOM(ncxXML);
        },
        tocIsNcx : function () {
            return packageDoc.tocIsNcx();
        }
    };
};

    var EpubReaderModule = function(readerBoundElement, epubSpineInfo, viewerSettings, packageDocumentDOM, renderStrategy) {

    var EpubReader = {};

    // Rationale: The order of these matters
    EpubReader.LoadStrategy = Backbone.Model.extend({

    defaults : {
        "numFixedPagesPerView" : 100
    },

    initialize : function (attributes, options) {},

    // Description: This method chooses the appropriate page view to load for individual 
    //   spine items, and sections of the spine. 
    loadSpineItems : function (viewerSettings, annotations, bindings) {

        var spineIndex;
        var currSpineItem;
        var currFixedSpineItems = [];
        var nextSpineItem;
        var pagesViews = [];
        var currPageView;
        var nextSpineItem;
        for (spineIndex = 0; spineIndex <= this.get("spineInfo").length - 1; spineIndex++) {

            currSpineItem = this.get("spineInfo")[spineIndex];

            // A fixed layout spine item
            if (currSpineItem.isFixedLayout) {

                currFixedSpineItems.push(currSpineItem);

                // Check how many fixed pages have been added for the next view
                if (currFixedSpineItems.length === this.get("numFixedPagesPerView")) {

                    currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                    pagesViews.push(currPageView);
                    currFixedSpineItems = [];
                    continue;
                }

                nextSpineItem = this.get("spineInfo")[spineIndex + 1];
                if (nextSpineItem) {

                    if (!nextSpineItem.isFixedLayout) {

                        currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                        pagesViews.push(currPageView);
                        currFixedSpineItems = [];
                    }
                }
                else {
                    currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                    pagesViews.push(currPageView);
                    currFixedSpineItems = [];
                }
            }
            // A scrolling spine item 
            else if (currSpineItem.shouldScroll) {

                // Load the scrolling pages view
            }
            // A reflowable spine item
            else {
                currPageView = this.loadReflowablePagesView(currSpineItem, viewerSettings, annotations, bindings);
                pagesViews.push(currPageView);
            }
        }

        return pagesViews;
    },

    loadReflowablePagesView : function (spineItem, viewerSettings, annotations, bindings) {

        var view = new EpubReflowableModule(
            spineItem,
            viewerSettings, 
            annotations, 
            bindings
        );

        var pagesViewInfo = {
            pagesView : view, 
            spineIndexes : [spineItem.spineIndex],
            isRendered : false,
            type : "reflowable"
        };

        return pagesViewInfo;
    },

    loadFixedPagesView : function (spineItemList, viewerSettings) {

        var view = new EpubFixedModule(
            spineItemList,
            viewerSettings
        );

        var spineIndexes = [];
        _.each(spineItemList, function (spineItem) {
            spineIndexes.push(spineItem.spineIndex)
        });

        var pagesViewInfo = {
            pagesView : view, 
            spineIndexes : spineIndexes,
            isRendered : false,
            type : "fixed"
        };

        return pagesViewInfo;
    }
});
    EpubReader.EpubReader = Backbone.Model.extend({

    defaults : function () { 
        return {
            "loadedPagesViews" : [],
            "currentPagesViewIndex" : 0,
            "pagesViewEventList" : []
        };
    },

    initialize : function (attributes, options) {

        var spineInfo = this.get("spineInfo");
        this.set("spine", spineInfo.spine);
        this.set("bindings", spineInfo.bindings);
        this.set("annotations", spineInfo.annotations);
        this.get("viewerSettings").customStyles = [];

        this.loadStrategy = new EpubReader.LoadStrategy({ spineInfo : this.get("spine")});
        this.cfi = new EpubCFIModule();
    },

    // ------------------------------------------------------------------------------------ //  
    //  "PUBLIC" INTERFACE                                                                  //
    // ------------------------------------------------------------------------------------ //  

    // Description: This method chooses the appropriate page view to load for individual 
    //   spine items, and sections of the spine. 
    loadSpineItems : function () {

        var pagesViews = this.loadStrategy.loadSpineItems(this.get("viewerSettings"), this.get("annotations"), this.get("bindings"));
        this.set("loadedPagesViews", pagesViews);

        if (this.get("renderStrategy") === "eager") {
            this.eagerRenderStrategy();    
        }
        else if (this.get("renderStrategy") === "lazy") {
            this.trigger("epubLoaded");
        }
    },

    numberOfLoadedPagesViews : function () {

        return this.get("loadedPagesViews").length;
    },

    hasNextPagesView : function () {

        return this.get("currentPagesViewIndex") < this.numberOfLoadedPagesViews() - 1 ? true : false;
    },

    hasPreviousPagesView : function () {

        return this.get("currentPagesViewIndex") > 0 ? true : false;
    },

    getCurrentPagesView : function () {

        return this.get("loadedPagesViews")[this.get("currentPagesViewIndex")].pagesView;
    },

    renderPagesView : function (pagesViewIndex, callback, callbackContext) {

        var pagesViewInfo;
        var pagesView;
        var that = this;

        if (pagesViewIndex >= 0 && pagesViewIndex < this.numberOfLoadedPagesViews()) {

            this.hideRenderedViews();
            this.set({"currentPagesViewIndex" : pagesViewIndex});
            pagesViewInfo = this.getCurrentPagesViewInfo();
            pagesView = pagesViewInfo.pagesView;

            if (pagesViewInfo.isRendered) {

                pagesView.showPagesView();
                this.applyPreferences(pagesView);
                this.fitCurrentPagesView();
                callback.call(callbackContext, pagesView);
            }
            else {
                
                // Invoke callback when the content document loads
                pagesView.on("contentDocumentLoaded", function (result) {

                    pagesView.showPagesView();
                    that.applyPreferences(pagesView);

                    _.each(that.get("pagesViewEventList"), function (eventInfo) {
                        pagesView.on(eventInfo.eventName, eventInfo.callback, eventInfo.callbackContext);
                    });

                    callback.call(callbackContext, pagesView);
                }, this);

                $(this.get("parentElement")).append(pagesView.render(false, undefined));
                that.setLastRenderSize(pagesViewInfo, $(that.get("parentElement")).height(), $(that.get("parentElement")).width());
                pagesViewInfo.isRendered = true;
            }
        }
    },

    getRenderedPagesView : function (spineIndex, callback, callbackContext) {

        // Get pages view info
        var that = this;
        var viewElement;
        var pagesViewInfo = this.getPagesViewInfo(spineIndex);

        // Check if it is rendered
        if (!pagesViewInfo.isRendered) {

            // invoke callback when the content document loads
            pagesViewInfo.pagesView.on("contentDocumentLoaded", function (pagesView) {
                that.applyPreferences(pagesViewInfo.pagesView);
                callback.call(callbackContext, pagesViewInfo.pagesView);
            });

            // Note This logic is duplicated and should be abstracted
            viewElement = pagesViewInfo.pagesView.render(false, undefined);
            $(this.get("parentElement")).append(viewElement);
            that.setLastRenderSize(pagesViewInfo, $(that.get("parentElement")).height(), $(that.get("parentElement")).width());
            pagesViewInfo.isRendered = true;
        }
        else {
            callback.call(callbackContext, pagesViewInfo.pagesView);
        }
    },

    renderNextPagesView : function (callback, callbackContext) {

        var nextPagesViewIndex = this.get("currentPagesViewIndex") + 1;
        this.renderPagesView(nextPagesViewIndex, function (pagesView) {

            pagesView.showPageByNumber(1);
            callback.call(callbackContext);
        }, callbackContext);
    },

    renderPreviousPagesView : function (callback, callbackContext) {

        var previousPagesViewIndex = this.get("currentPagesViewIndex") - 1;
        this.renderPagesView(previousPagesViewIndex, function (pagesView) {

            pagesView.showPageByNumber(pagesView.numberOfPages());
            callback.call(callbackContext);
        }, callbackContext);
    },

    attachEventHandler : function (eventName, callback, callbackContext) {

        // Rationale: Maintain a list of the callbacks, which need to be attached when pages views are loaded
        this.get("pagesViewEventList").push({
            eventName : eventName,
            callback : callback,
            callbackContext : callbackContext
        });

        // Attach the event handler to each current pages view
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {
            pagesViewInfo.pagesView.on(eventName, callback, callbackContext);
        }, this);
    },

    removeEventHandler : function (eventName) {

        var that = this;
        // Find index of events
        var indexOfEventsToRemove = [];
        _.each(this.get("pagesViewEventList"), function (pagesViewEvent, index) {

            if (pagesViewEvent.eventName === eventName) {
                indexOfEventsToRemove.push(index);
            }
        });

        // Remove them in reverse order, so each index is still valid
        indexOfEventsToRemove.reverse();
        _.each(indexOfEventsToRemove, function (indexToRemove) {
            that.get("pagesViewEventList").splice(indexToRemove, 1);
        });

        // Remove event handlers on views
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {
            pagesViewInfo.pagesView.off(eventName);
        }, this);
    },

    // REFACTORING CANDIDATE: For consistency, it might make more sense if each of the page sets kept track
    //   of their own last size and made the decision as to whether to resize or not. Or maybe that doesn't make
    //   sense.... something to think about. 
    fitCurrentPagesView : function () {

        var readerElementHeight = this.get("parentElement").height();
        var readerElementWidth = this.get("parentElement").width();

        var currPagesViewInfo = this.getCurrentPagesViewInfo();
        var heightIsDifferent = currPagesViewInfo.lastRenderHeight !== readerElementHeight ? true : false;
        var widthIsDifferent = currPagesViewInfo.lastRenderWidth !== readerElementWidth ? true : false;

        if (heightIsDifferent || widthIsDifferent) {
            this.setLastRenderSize(currPagesViewInfo, readerElementHeight, readerElementWidth);
            currPagesViewInfo.pagesView.resizeContent();
        }
    },

    // Description: Finds the first spine index in the primary reading order
    getFirstSpineIndex : function () {

        var foundSpineItem = _.find(this.get("spine"), function (spineItem, index) { 

            if (spineItem.linear) {
                return true;
            }
        });

        return foundSpineItem.spineIndex;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    eagerRenderStrategy : function () {

        var that = this;
        var numPagesViewsToLoad = this.get("loadedPagesViews").length;
        
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {

            pagesViewInfo.pagesView.on("contentDocumentLoaded", function (viewElement) { 

                pagesViewInfo.isRendered = true;
                pagesViewInfo.pagesView.hidePagesView();

                numPagesViewsToLoad = numPagesViewsToLoad - 1; 
                if (numPagesViewsToLoad === 0) {
                    that.trigger("epubLoaded");
                }

                // Attach list of event handlers
                _.each(that.get("pagesViewEventList"), function (eventInfo) {
                    pagesViewInfo.pagesView.on(eventInfo.eventName, eventInfo.callback, eventInfo.callbackContext);
                });
            });
            
            // This will cause the pages view to try to retrieve its resources
            $(that.get("parentElement")).append(pagesViewInfo.pagesView.render(false, undefined));
            that.setLastRenderSize(pagesViewInfo, $(that.get("parentElement")).height(), $(that.get("parentElement")).width());
        });

        setTimeout(function () { 
            
            if (numPagesViewsToLoad != 0) {
                // throw an exception
            }

        }, 1000);
    },

    getCurrentPagesViewInfo : function () {

        return this.get("loadedPagesViews")[this.get("currentPagesViewIndex")];
    },

    hideRenderedViews : function () {

        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {

            if (pagesViewInfo.isRendered) {
                pagesViewInfo.pagesView.hidePagesView();
            }
        });
    },

    // REFACTORING CANDIDATE: This method should be replaced when the epub reader api is changed to have an 
    //   instantiated epub module passed to it. 
    findSpineIndex : function (contentDocumentHref) {

        var contentDocHref = contentDocumentHref;
        var foundSpineItem;

        foundSpineItem = _.find(this.get("spine"), function (spineItem, index) { 

            var uri = new URI(spineItem.contentDocumentURI);
            var filename = uri.filename();
            if (contentDocumentHref.trim() === filename.trim()) {
                return true;
            }
        });

        return foundSpineItem.spineIndex;
    },

    getPagesViewInfo : function (spineIndex) {

        var foundPagesViewInfo = _.find(this.get("loadedPagesViews"), function (currPagesViewInfo, index) {

            var foundSpineIndex = _.find(currPagesViewInfo.spineIndexes, function (currSpineIndex) {
                if (currSpineIndex === spineIndex) {
                    return true;
                }
            });

            // Only checking for null and undefined, as "foundSpineIndex" can be 0, which evaluates as falsy
            if (foundSpineIndex !== undefined && foundSpineIndex !== null) {
                return true;
            }
        });

        return foundPagesViewInfo;
    },

    getPagesViewIndex : function (spineIndex) {

        var foundPagesViewIndex;
        _.find(this.get("loadedPagesViews"), function (currPagesViewInfo, index) {

            var foundSpineIndex = _.find(currPagesViewInfo.spineIndexes, function (currSpineIndex) {
                if (currSpineIndex === spineIndex) {
                    return true;
                }
            });

            // Only checking for null and undefined, as "foundSpineIndex" can be 0, which evaluates as falsy
            if (foundSpineIndex !== undefined && foundSpineIndex !== null) {
                foundPagesViewIndex = index;
                return true;
            }
        });

        return foundPagesViewIndex;
    },

    applyPreferences : function (pagesView) {

        var preferences = this.get("viewerSettings");
        pagesView.setSyntheticLayout(preferences.syntheticLayout);

        // Apply all current preferences to the next page set
        pagesView.customize("margin", preferences.currentMargin + "");
        pagesView.customize("fontSize", preferences.fontSize + "")
        _.each(preferences.customStyles, function (customStyle) {
            pagesView.customize(customStyle.customProperty, customStyle.styleNameOrCSSObject);
        });
    },

    setLastRenderSize : function (pagesViewInfo, height, width) {

        pagesViewInfo.lastRenderHeight = height;
        pagesViewInfo.lastRenderWidth = width;
    }
});
    EpubReader.EpubReaderView = Backbone.View.extend({

    pageSetEvents : {
        "contentDocumentLoaded" : false,
        "epubLinkClicked" : true,
        "atNextPage" : false,
        "atPreviousPage" : false,
        "atFirstPage" : false,
        "atLastPage" : false,
        "layoutChanged" : false,
        "displayedContentChanged" : false,
        "annotationClicked" : true
    },

    initialize : function (options) {

        var that = this;
        this.packageDocumentDOM = options.packageDocumentDOM;
        this.reader = new EpubReader.EpubReader({
            spineInfo : $.extend(true, {}, options.spineInfo),
            viewerSettings : $.extend(true, {}, options.viewerSettings),
            parentElement : $(options.readerElement),
            renderStrategy : options.renderStrategy
        });
        // Rationale: Propagate the loaded event after all the content documents are loaded
        this.reader.on("epubLoaded", function () {
            that.trigger("epubLoaded");
            // that.$el.css("opacity", "1");
        }, this);
        this.startPropogatingEvents();

        this.readerBoundElement = options.readerElement;
        this.cfi = new EpubCFIModule();
    },

    render : function () {

        // Set the element that this view will be bound to
        $(this.readerBoundElement).css("opacity", "0");
        this.setElement(this.readerBoundElement);
        this.reader.loadSpineItems();
        return this.el;
    },

    // ------------------------ Public interface ------------------------------------------------------------------------

    showSpineItem : function (spineIndex, callback, callbackContext) {

        var that = this;
        var pagesViewIndex = this.reader.getPagesViewIndex(spineIndex);
        this.$el.css("opacity", "0");
        this.reader.renderPagesView(pagesViewIndex, function () {

            var pagesViewInfo = this.reader.getCurrentPagesViewInfo();

            // If the pages view is fixed
            // REFACTORING CANDIDATE: This will cause a displayedContentChanged event to be triggered twice when another show
            //   method calls this to first load the spine item; Part of this method could be extracted and turned into a 
            //   helper to prevent this.
            if (pagesViewInfo.type === "fixed") {
                pageNumber = that.getPageNumber(pagesViewInfo, spineIndex);
                pagesViewInfo.pagesView.showPageByNumber(pageNumber);
            }
            else {
                pagesViewInfo.pagesView.showPageByNumber(1);    
            }
            
            that.$el.css("opacity", "1");
            callback.call(callbackContext);
        }, this);
    },

    showFirstPage : function (callback, callbackContext) {

        var firstSpineIndexInReadingOrder = this.reader.getFirstSpineIndex();
        this.showSpineItem(firstSpineIndexInReadingOrder, function () {
            callback.call(callbackContext);
        }, this);
    },

    // Rationale: As with the CFI library API, it is up to calling code to ensure that the content document CFI component is
    //   is a reference into the content document pointed to by the supplied spine index. 
    showPageByCFI : function (CFI, callback, callbackContext) {

        // Dereference CFI, get the content document href
        var contentDocHref;
        var spineIndex;
        var pagesView;
        try {
            
            contentDocHref = this.cfi.getContentDocHref(CFI, this.packageDocumentDOM);
            spineIndex = this.reader.findSpineIndex(contentDocHref);
            this.showSpineItem(spineIndex, function () {
                pagesView = this.reader.getCurrentPagesView();
                pagesView.showPageByCFI(CFI);
                callback.call(callbackContext);
            }, this);
        }
        catch (error) {
            throw error; 
        }
    },

    showPageByElementId : function (spineIndex, elementId, callback, callbackContext) { 

        // Rationale: Try to locate the element before switching to a new page view try/catch
        this.showSpineItem(spineIndex, function () {
            this.reader.getCurrentPagesView().showPageByHashFragment(elementId);
            callback.call(callbackContext);
        }, this);
    },

    nextPage : function (callback, callbackContext) {

        var that = this;
        var currentPagesView = this.reader.getCurrentPagesView();

        if (currentPagesView.onLastPage()) {

            if (this.reader.hasNextPagesView()) {

                this.$el.css("opacity", "0");
                this.reader.renderNextPagesView(function () {

                    that.$el.css("opacity", "1");
                    that.trigger("atNextPage");
                    callback.call(callbackContext);
                }, this);
            }
            else {
                this.trigger("atLastPage");
                callback.call(callbackContext);
            }
        }
        else {
            currentPagesView.nextPage();
            if (currentPagesView.onLastPage() && !this.reader.hasNextPagesView()) {
                that.trigger("atLastPage");
            }
        }
    },

    previousPage : function (callback, callbackContext) {

        var that = this;
        var currentPagesView = this.reader.getCurrentPagesView();

        if (currentPagesView.onFirstPage()) {

            if (this.reader.hasPreviousPagesView()) {
                
                this.$el.css("opacity", "0");
                this.reader.renderPreviousPagesView(function () {

                    that.$el.css("opacity", "1");
                    that.trigger("atPreviousPage");
                    callback.call(callbackContext);
                }, this);
            }
            else {
                this.trigger("atFirstPage");
                callback.call(callbackContext);
            }
        }
        else {
            currentPagesView.previousPage();
            if (currentPagesView.onFirstPage() && !this.reader.hasPreviousPagesView()) {
                that.trigger("atFirstPage");
            }
        }
    },

    // REFACTORING CANDIDATE: setFontSize and setMargin can be rolled into the custom
    //   proprety infrastructure at some point
    customize : function (customProperty, styleNameOrCSSObject) {
        var currentView = this.reader.getCurrentPagesView();

        // delegate to font size, margin and theme
        if (customProperty === "fontSize") {
			var fontSize = parseInt(styleNameOrCSSObject);

			currentView.customize(customProperty, fontSize);
			this.reader.get("viewerSettings").fontSize = fontSize;
        }
        else if (customProperty === "margin") {
			var margin = parseInt(styleNameOrCSSObject);

			currentView.customize(customProperty, margin);
			this.reader.get("viewerSettings").currentMargin = margin;
        }
        else {
            currentView.customize(customProperty, styleNameOrCSSObject);
            this.reader.get("viewerSettings")["customStyles"].push({ 
                "customProperty" : customProperty,
                "styleNameOrCSSObject" : styleNameOrCSSObject
            });
        }
    },

    setSyntheticLayout : function (isSynthetic) {

        var currentView = this.reader.getCurrentPagesView();
        currentView.setSyntheticLayout(isSynthetic);
        this.reader.get("viewerSettings").syntheticLayout = isSynthetic;
    },

    getViewerSettings : function () {

        return this.reader.get("viewerSettings");
    },

    attachEventHandler : function (eventName, callback, callbackContext) {

        // Page set events
        if (this.canHandlePageSetEvent(eventName)) {
            this.reader.attachEventHandler(eventName, callback, callbackContext);
        }
        // Reader events
        else {
            this.on(eventName, callback, callbackContext);
        }
    },

    removeEventHandler : function (eventName) {

        // Page set events
        if (this.canHandlePageSetEvent(eventName)) {
            this.reader.removeEventHandler(eventName);
        }
        // Reader events
        else {
            this.off(eventName);
        }
    },

    // ----------------------- Private Helpers -----------------------------------------------------------

    getSpineIndexFromCFI : function (CFI) {

        try {
            var contentDocumentHref = this.cfi.getContentDocHref(CFI, this.packageDocumentDOM);
            var spineIndex = this.reader.findSpineIndex(contentDocumentHref);
            return spineIndex;
        }
        catch (error) {
            throw error;
        }
    },

    getPageNumber : function (fixedPagesViewInfo, spineIndex) {

        var spineIndexes = fixedPagesViewInfo.spineIndexes;
        var pageNumber = undefined;

        _.each(spineIndexes, function (currSpineIndex, index) {

            if (currSpineIndex === spineIndex) {
                pageNumber = index + 1;
                return true;
            }
        });

        return pageNumber;
    },

    canHandlePageSetEvent : function (eventName) {

        if (this.pageSetEvents[eventName] === true) {
            return true;
        }
        else {
            return false;
        }
    },

    // Rationale: The reader is responsible for propagating these events in certain cases
    startPropogatingEvents : function () {

        this.reader.attachEventHandler("atNextPage", function () {
            this.trigger("atNextPage");
        }, this);

        this.reader.attachEventHandler("atPreviousPage", function () {
            this.trigger("atPreviousPage");
        }, this);

        this.reader.attachEventHandler("layoutChanged", function (isSynthetic) {
            this.trigger("layoutChanged", isSynthetic);
        }, this);

        this.reader.attachEventHandler("displayedContentChanged", function () {
            this.trigger("displayedContentChanged");
        }, this);        
    },

    addSelectionHighlight : function (id, type) {

        var contentDocCFIComponent;
        var packageDocCFIComponent;
        var completeCFI;
        var spineIndex;
        var currentViewInfo = this.reader.getCurrentPagesViewInfo();
        spineIndex = currentViewInfo.spineIndexes[0]; // Assumes reflowable
        annotationInfo = currentViewInfo.pagesView.addSelectionHighlight(id, type);

        // Generate a package document cfi component and construct the whole cfi, append
        contentDocCFIComponent = annotationInfo.CFI;
        packageDocCFIComponent = this.cfi.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, this.packageDocumentDOM);
        completeCFI = this.cfi.generateCompleteCFI(packageDocCFIComponent, contentDocCFIComponent);
        annotationInfo.CFI = completeCFI;

        return annotationInfo;
    },

    addSelectionBookmark : function (id) {

        var contentDocCFIComponent;
        var packageDocCFIComponent;
        var completeCFI;
        var spineIndex;
        var currentViewInfo = this.reader.getCurrentPagesViewInfo();
        spineIndex = currentViewInfo.spineIndexes[0]; // Assumes reflowable
        annotationInfo = currentViewInfo.pagesView.addSelectionBookmark(id);

        // Generate a package document cfi component and construct the whole cfi, append
        contentDocCFIComponent = annotationInfo.CFI;
        packageDocCFIComponent = this.cfi.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, this.packageDocumentDOM);
        completeCFI = this.cfi.generateCompleteCFI(packageDocCFIComponent, contentDocCFIComponent);
        annotationInfo.CFI = completeCFI;

        return annotationInfo;
    },

    addSelectionImageAnnotation : function (id) {

        var contentDocCFIComponent;
        var packageDocCFIComponent;
        var completeCFI;
        var spineIndex;
        var currentViewInfo = this.reader.getCurrentPagesViewInfo();
        spineIndex = currentViewInfo.spineIndexes[0]; // Assumes reflowable
        annotationInfo = currentViewInfo.pagesView.addSelectionImageAnnotation(id);

        // Generate a package document cfi component and construct the whole cfi, append
        contentDocCFIComponent = annotationInfo.CFI;
        packageDocCFIComponent = this.cfi.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, this.packageDocumentDOM);
        completeCFI = this.cfi.generateCompleteCFI(packageDocCFIComponent, contentDocCFIComponent);
        annotationInfo.CFI = completeCFI;

        return annotationInfo;
    },

    addHighlight : function (CFI, id, type, callback, callbackContext) {

        var annotationInfo;
        var contentDocSpineIndex = this.getSpineIndexFromCFI(CFI);
        this.reader.getRenderedPagesView(contentDocSpineIndex, function (pagesView) {

            try {
                annotationInfo = pagesView.addHighlight(CFI, id, type);
                callback.call(callbackContext, undefined, contentDocSpineIndex, CFI, annotationInfo);
            }
            catch (error) {
                callback.call(callbackContext, error, undefined, undefined);
            }
        });
    },

    addBookmark : function (CFI, id, callback, callbackContext) {

        var annotationInfo;
        var contentDocSpineIndex = this.getSpineIndexFromCFI(CFI);
        this.reader.getRenderedPagesView(contentDocSpineIndex, function (pagesView) {

            try {
                annotationInfo = pagesView.addBookmark(CFI, id);
                callback.call(callbackContext, undefined, contentDocSpineIndex, CFI, annotationInfo);
            }
            catch (error) {
                callback.call(callbackContext, error, undefined, undefined);
            }
        });
    },

    addImageAnnotation : function (CFI, id, callback, callbackContext) {

        var annotationInfo;
        var contentDocSpineIndex = this.getSpineIndexFromCFI(CFI);
        this.reader.getRenderedPagesView(contentDocSpineIndex, function (pagesView) {

            try {
                annotationInfo = pagesView.addImageAnnotation(CFI, id);
                callback.call(callbackContext, undefined, contentDocSpineIndex, CFI, annotationInfo);
            }
            catch (error) {
                callback.call(callbackContext, error, undefined, undefined);
            }
        });
    },    
});


    var epubReaderView = new EpubReader.EpubReaderView({
        readerElement : readerBoundElement,
        spineInfo : epubSpineInfo,
        viewerSettings : viewerSettings,
        packageDocumentDOM : packageDocumentDOM,
        renderStrategy : renderStrategy
    });

    // Description: The public interface
    return {

        render : function () {
            return epubReaderView.render();
        },
        showFirstPage : function (callback, callbackContext) {
            return epubReaderView.showFirstPage(callback, callbackContext);
        },
        showSpineItem : function (spineIndex, callback, callbackContext) {
            return epubReaderView.showSpineItem(spineIndex, callback, callbackContext);
        },
        showPageByCFI : function (CFI, callback, callbackContext) {
            return epubReaderView.showPageByCFI(CFI, callback, callbackContext);
        },
        showPageByElementId : function (spineIndex, hashFragmentId, callback, callbackContext) {
            return epubReaderView.showPageByElementId(spineIndex, hashFragmentId, callback, callbackContext);
        },
        nextPage : function (callback, callbackContext) {
            return epubReaderView.nextPage(callback, callbackContext);
        },
        previousPage : function (callback, callbackContext) {
            return epubReaderView.previousPage(callback, callbackContext);
        },
        setSyntheticLayout : function (isSynthetic) {
            return epubReaderView.setSyntheticLayout(isSynthetic);
        },
        on : function (eventName, callback, callbackContext) {
            return epubReaderView.attachEventHandler(eventName, callback, callbackContext);
        },
        off : function (eventName) {
            return epubReaderView.removeEventHandler(eventName);
        },
        getViewerSettings : function () {
            return epubReaderView.getViewerSettings();
        },
        resizeContent : function () {
            return epubReaderView.reader.fitCurrentPagesView();
        },
        customize : function (customProperty, styleNameOrCSS) {
            epubReaderView.customize(customProperty, styleNameOrCSS);
            return this;
        },
        addSelectionHighlight : function (id, type) { 
            return epubReaderView.addSelectionHighlight(id, type); 
        },
        addSelectionBookmark : function (id) { 
            return epubReaderView.addSelectionBookmark(id); 
        },
        addSelectionImageAnnotation : function (id) {
            return epubReaderView.addSelectionImageAnnotation(id);
        },
        addHighlight : function (CFI, id, type, callback, callbackContext) { 
            return epubReaderView.addHighlight(CFI, id, type, callback, callbackContext); 
        },
        addBookmark : function (CFI, id, callback, callbackContext) { 
            return epubReaderView.addBookmark(CFI, id, callback, callbackContext); 
        },
        addImageAnnotation : function (CFI, id, callback, callbackContext) { 
            return epubReaderView.addImageAnnotation(CFI, id, callback, callbackContext); 
        }
    };
};


    // -------------- Initialization of viewer ------------------ //
    var epubParser = new EpubParserModule(packageDocumentURL, packageDocumentXML);
    var packageDocumentDOM = (new window.DOMParser()).parseFromString(packageDocumentXML, "text/xml");
    var epub = new EpubModule(epubParser.parse(), packageDocumentXML);
    var epubViewer = new EpubReaderModule(
        elementToBindReaderTo,
        epub.getSpineInfo(),
        viewerPreferences,
        packageDocumentDOM,
        renderStrategy
    );

    // Description: The public interface
    return {

        // epub module api
        // -- None added so far 

        // epub viewer module api
        render : function () { 
            return epubViewer.render(); 
        },
        showFirstPage : function (callback, callbackContext) {
            return epubViewer.showFirstPage(callback, callbackContext);
        },
        showSpineItem : function (spineIndex, callback, callbackContext) { 
            return epubViewer.showSpineItem(spineIndex, callback, callbackContext); 
        },
        showPageByCFI : function (CFI, callback, callbackContext) { 
            return epubViewer.showPageByCFI(CFI, callback, callbackContext); 
        },
        showPageByElementId : function (spineIndex, hashFragmentId, callback, callbackContext) { 
            return epubViewer.showPageByElementId(spineIndex, hashFragmentId, callback, callbackContext); 
        },
        nextPage : function (callback, callbackContext) { 
            return epubViewer.nextPage(callback, callbackContext); 
        },
        previousPage : function (callback, callbackContext) { 
            return epubViewer.previousPage(callback, callbackContext); 
        },
        setFontSize : function (fontSize) { 
            return epubViewer.setFontSize(fontSize); 
        },
        setMargin : function (margin) { 
            return epubViewer.setMargin(margin); 
        },
        setTheme : function (theme) { 
            return epubViewer.setTheme(theme); 
        },
        setSyntheticLayout : function (isSynthetic) { 
            return epubViewer.setSyntheticLayout(isSynthetic); 
        },
        getNumberOfPages : function () { 
            return epubViewer.getNumberOfPages(); 
        },
        getCurrentPage : function () { 
            return epubViewer.getCurrentPage.call(epubViewer); 
        },
        on : function (eventName, callback, callbackContext) { 
            return epubViewer.on(eventName, callback, callbackContext); 
        },
        off : function (eventName) { 
            return epubViewer.off(eventName); 
        }, 
        getViewerSettings : function () { 
            return epubViewer.getViewerSettings(); 
        },
        resizeContent : function () { 
            return epubViewer.resizeContent(); 
        },
        customize : function (customElement, styleNameOrCSSObject) {
            epubViewer.customize(customElement, styleNameOrCSSObject);
            return this;
        }
    };
};
